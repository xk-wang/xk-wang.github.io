<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XK</title>
  <icon>https://www.gravatar.com/avatar/4a844ada4cba7aee005f4edded2b07b9</icon>
  <subtitle>为者常成，行者常至</subtitle>
  <link href="http://xkwang.cn/atom.xml" rel="self"/>
  
  <link href="http://xkwang.cn/"/>
  <updated>2021-04-25T14:33:40.837Z</updated>
  <id>http://xkwang.cn/</id>
  
  <author>
    <name>xkwang</name>
    <email>xk_wang@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mmpose进行姿态估计</title>
    <link href="http://xkwang.cn/post/cd105779.html"/>
    <id>http://xkwang.cn/post/cd105779.html</id>
    <published>2021-04-25T14:24:34.000Z</published>
    <updated>2021-04-25T14:33:40.837Z</updated>
    
    <content type="html"><![CDATA[<p>Lite-HRNet是开高效姿态估计算法，只有20多M参数，放到移动设备上很方便。</p><a id="more"></a><h4 id="Lite-HRNet"><a href="#Lite-HRNet" class="headerlink" title="Lite-HRNet"></a>Lite-HRNet</h4><p>mmpose是商汤开源的用于姿态估计的库，对很多姿态估计算法都进行过了封装，且提供了相应的模型参数文件，使用起来十分方便。2018年出了一篇HRNet用来人体关键点估计的论文，刷新了COCO数据集和其它数据集的关键点检测分数。不过原本的HRNet使用pytorch进行编程，代码量还是不少，看的也是云里雾里，最近我校自动化学院出了一篇Lite-HRNet论文，发表在CVPR2021上，且模型使用商汤的mmpose和mmcv来进行编写，模型结构代码量只有900多行，结合论文很容易理解。</p><p>Lite-HRNet使用shuffleNet module和conditional channel weighting来优化1*1卷积计算量，使得模型参数和计算量大大减少，整个模型只有20多M，效果用起来也非常好。不过目前商汤官方mmpose还没把Lite-HRNet加入其中，后续估计在新版中加入。由于Lite-HRNet的代码完全遵循商汤的mmpose规范来写，因此自己能够很轻松的将Lite-HRNet注册到mmpose中进行调用。</p><p>原始的hrnet如下</p><div style="text-align: center"><img src="/assets/blog/cd105779/hrnet.jpg" margin="0 auto" width="50%" height="50%"/></div><p>litehrnet如下</p><div style="text-align: center"><img src="/assets/blog/cd105779/litehrnet1.jpg" margin="0 auto" width="50%" height="50%"/></div><div style="text-align: center"><img src="/assets/blog/cd105779/litehrnet2.jpg" margin="0 auto" width="50%" height="50%"/></div><p>其中conditional channel weighting内部结构如下图(b)，其中图(a)是标准的shuffle net模块：</p><div style="text-align: center"><img src="/assets/blog/cd105779/condition.png" margin="0 auto" width="50%" height="50%"/></div><h4 id="Lite-HRNet代码注释版"><a href="#Lite-HRNet代码注释版" class="headerlink" title="Lite-HRNet代码注释版"></a>Lite-HRNet代码注释版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConvModule和build_conv_layer都可以用来构建卷积层，区别是build_conv_layer更强大</span></span><br><span class="line"><span class="comment"># 可以从一个配置参来来构建卷积</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ConvModule可以实现分组卷积，DepthwiseSeparableConvModule是实现深度可分离式卷积</span></span><br><span class="line"><span class="comment"># 将分组卷积的组数设置成通道数就是分离式卷积了，不过分离式卷积是通过1*1卷积来实现</span></span><br><span class="line"><span class="comment"># 通道融合和变通道，分组卷积是通过后续借助channel shuffle+1*1卷积</span></span><br><span class="line"><span class="keyword">from</span> mmcv.cnn <span class="keyword">import</span> (ConvModule, DepthwiseSeparableConvModule,</span><br><span class="line">                      build_conv_layer, build_norm_layer, constant_init,</span><br><span class="line">                      normal_init)</span><br><span class="line"><span class="keyword">from</span> torch.nn.modules.batchnorm <span class="keyword">import</span> _BatchNorm</span><br><span class="line"><span class="keyword">import</span> torch.utils.checkpoint <span class="keyword">as</span> cp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mmcv</span><br><span class="line"><span class="keyword">from</span> mmpose.utils <span class="keyword">import</span> get_root_logger</span><br><span class="line"><span class="keyword">from</span> mmpose.models.registry <span class="keyword">import</span> BACKBONES</span><br><span class="line"><span class="keyword">from</span> mmpose.models.backbones.resnet <span class="keyword">import</span> BasicBlock, Bottleneck</span><br><span class="line"><span class="keyword">from</span> mmpose.models.backbones.utils <span class="keyword">import</span> load_checkpoint, channel_shuffle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是论文中提到的两个weighting</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpatialWeighting</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ratio=<span class="number">16</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 act_cfg=(<span class="params"><span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span></span>), <span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;Sigmoid&#x27;</span></span>)</span>)</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(act_cfg, <span class="built_in">dict</span>):</span><br><span class="line">            act_cfg = (act_cfg, act_cfg)</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(act_cfg) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> mmcv.is_tuple_of(act_cfg, <span class="built_in">dict</span>)</span><br><span class="line">        self.global_avgpool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">        self.conv1 = ConvModule(</span><br><span class="line">            in_channels=channels,</span><br><span class="line">            out_channels=<span class="built_in">int</span>(channels / ratio),</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            act_cfg=act_cfg[<span class="number">0</span>])</span><br><span class="line">        self.conv2 = ConvModule(</span><br><span class="line">            in_channels=<span class="built_in">int</span>(channels / ratio),</span><br><span class="line">            out_channels=channels,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            act_cfg=act_cfg[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.global_avgpool(x)</span><br><span class="line">        out = self.conv1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        <span class="keyword">return</span> x * out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossResolutionWeighting</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ratio=<span class="number">16</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 act_cfg=(<span class="params"><span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span></span>), <span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;Sigmoid&#x27;</span></span>)</span>)</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(act_cfg, <span class="built_in">dict</span>):</span><br><span class="line">            act_cfg = (act_cfg, act_cfg)</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(act_cfg) == <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> mmcv.is_tuple_of(act_cfg, <span class="built_in">dict</span>)</span><br><span class="line">        self.channels = channels</span><br><span class="line">        total_channel = <span class="built_in">sum</span>(channels)</span><br><span class="line">        self.conv1 = ConvModule(</span><br><span class="line">            in_channels=total_channel,</span><br><span class="line">            out_channels=<span class="built_in">int</span>(total_channel / ratio),</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg,</span><br><span class="line">            act_cfg=act_cfg[<span class="number">0</span>])</span><br><span class="line">        self.conv2 = ConvModule(</span><br><span class="line">            in_channels=<span class="built_in">int</span>(total_channel / ratio),</span><br><span class="line">            out_channels=total_channel,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg,</span><br><span class="line">            act_cfg=act_cfg[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        mini_size = x[-<span class="number">1</span>].size()[-<span class="number">2</span>:]</span><br><span class="line">        out = [F.adaptive_avg_pool2d(s, mini_size) <span class="keyword">for</span> s <span class="keyword">in</span> x[:-<span class="number">1</span>]] + [x[-<span class="number">1</span>]]</span><br><span class="line">        out = torch.cat(out, dim=<span class="number">1</span>)</span><br><span class="line">        out = self.conv1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = torch.split(out, self.channels, dim=<span class="number">1</span>)</span><br><span class="line">        out = [</span><br><span class="line">            s * F.interpolate(a, size=s.size()[-<span class="number">2</span>:], mode=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> s, a <span class="keyword">in</span> <span class="built_in">zip</span>(x, out)</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个部分是提出来的模块，论文中的对比图 ConditionalChannelWeighting</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConditionalChannelWeighting</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 in_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                 reduce_ratio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                 with_cp=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.with_cp = with_cp</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">assert</span> stride <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        branch_channels = [channel // <span class="number">2</span> <span class="keyword">for</span> channel <span class="keyword">in</span> in_channels]</span><br><span class="line"></span><br><span class="line">        self.cross_resolution_weighting = CrossResolutionWeighting(</span><br><span class="line">            branch_channels,</span><br><span class="line">            ratio=reduce_ratio,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg)</span><br><span class="line"></span><br><span class="line">        self.depthwise_convs = nn.ModuleList([</span><br><span class="line">            ConvModule(</span><br><span class="line">                channel,</span><br><span class="line">                channel,</span><br><span class="line">                kernel_size=<span class="number">3</span>,</span><br><span class="line">                stride=self.stride,</span><br><span class="line">                padding=<span class="number">1</span>,</span><br><span class="line">                groups=channel,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=<span class="literal">None</span>) <span class="keyword">for</span> channel <span class="keyword">in</span> branch_channels</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        self.spatial_weighting = nn.ModuleList([</span><br><span class="line">            SpatialWeighting(channels=channel, ratio=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span> channel <span class="keyword">in</span> branch_channels</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_inner_forward</span>(<span class="params">x</span>):</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># x是一个list，包含前一层的所有分辨率的tensor, 其中每个tensor</span></span><br><span class="line">            <span class="comment"># 尺寸[B, C, H, W]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每个tensor沿着通道均分成两个分支，实现分组卷积</span></span><br><span class="line">            x = [s.chunk(<span class="number">2</span>, dim=<span class="number">1</span>) <span class="keyword">for</span> s <span class="keyword">in</span> x]</span><br><span class="line">            x1 = [s[<span class="number">0</span>] <span class="keyword">for</span> s <span class="keyword">in</span> x] <span class="comment"># 图中左边分支</span></span><br><span class="line">            x2 = [s[<span class="number">1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> x] <span class="comment"># 图中右边分支</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分支2进行两中类型的1*1卷积</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># cross_resolution_weighting使用所有的分辨率特征图，实现跨分辨率融合</span></span><br><span class="line">            <span class="comment"># 实现方式是sharing weights</span></span><br><span class="line">            x2 = self.cross_resolution_weighting(x2)</span><br><span class="line">            x2 = [dw(s) <span class="keyword">for</span> s, dw <span class="keyword">in</span> <span class="built_in">zip</span>(x2, self.depthwise_convs)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># spatial_weighting使用每个分辨率自己的特侦图</span></span><br><span class="line">            <span class="comment"># 实现方式是不共享权重</span></span><br><span class="line">            x2 = [sw(s) <span class="keyword">for</span> s, sw <span class="keyword">in</span> <span class="built_in">zip</span>(x2, self.spatial_weighting)]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 合并shuffle</span></span><br><span class="line">            out = [torch.cat([s1, s2], dim=<span class="number">1</span>) <span class="keyword">for</span> s1, s2 <span class="keyword">in</span> <span class="built_in">zip</span>(x1, x2)]</span><br><span class="line">            out = [channel_shuffle(s, <span class="number">2</span>) <span class="keyword">for</span> s <span class="keyword">in</span> out]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.with_cp <span class="keyword">and</span> x.requires_grad:</span><br><span class="line">            out = cp.checkpoint(_inner_forward, x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out = _inner_forward(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stem</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 in_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stem_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 out_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 expand_ratio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                 with_cp=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.in_channels = in_channels</span><br><span class="line">        self.out_channels = out_channels</span><br><span class="line">        self.conv_cfg = conv_cfg</span><br><span class="line">        self.norm_cfg = norm_cfg</span><br><span class="line">        self.with_cp = with_cp</span><br><span class="line"></span><br><span class="line">        self.conv1 = ConvModule(</span><br><span class="line">            in_channels=in_channels,</span><br><span class="line">            out_channels=stem_channels,</span><br><span class="line">            kernel_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">2</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            conv_cfg=self.conv_cfg,</span><br><span class="line">            norm_cfg=self.norm_cfg,</span><br><span class="line">            act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        mid_channels = <span class="built_in">int</span>(<span class="built_in">round</span>(stem_channels * expand_ratio))</span><br><span class="line">        branch_channels = stem_channels // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> stem_channels == self.out_channels:</span><br><span class="line">            inc_channels = self.out_channels - branch_channels</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            inc_channels = self.out_channels - stem_channels</span><br><span class="line"></span><br><span class="line">        self.branch1 = nn.Sequential(</span><br><span class="line">            ConvModule(</span><br><span class="line">                branch_channels,</span><br><span class="line">                branch_channels,</span><br><span class="line">                kernel_size=<span class="number">3</span>,</span><br><span class="line">                stride=<span class="number">2</span>,</span><br><span class="line">                padding=<span class="number">1</span>,</span><br><span class="line">                groups=branch_channels,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=<span class="literal">None</span>),</span><br><span class="line">            ConvModule(</span><br><span class="line">                branch_channels,</span><br><span class="line">                inc_channels,</span><br><span class="line">                kernel_size=<span class="number">1</span>,</span><br><span class="line">                stride=<span class="number">1</span>,</span><br><span class="line">                padding=<span class="number">0</span>,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>)),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.expand_conv = ConvModule(</span><br><span class="line">            branch_channels,</span><br><span class="line">            mid_channels,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg,</span><br><span class="line">            act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>))</span><br><span class="line">        self.depthwise_conv = ConvModule(</span><br><span class="line">            mid_channels,</span><br><span class="line">            mid_channels,</span><br><span class="line">            kernel_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">2</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            groups=mid_channels,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg,</span><br><span class="line">            act_cfg=<span class="literal">None</span>)</span><br><span class="line">        self.linear_conv = ConvModule(</span><br><span class="line">            mid_channels,</span><br><span class="line">            branch_channels</span><br><span class="line">            <span class="keyword">if</span> stem_channels == self.out_channels <span class="keyword">else</span> stem_channels,</span><br><span class="line">            kernel_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            conv_cfg=conv_cfg,</span><br><span class="line">            norm_cfg=norm_cfg,</span><br><span class="line">            act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_inner_forward</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="comment"># 输入是原始的图像尺寸[B, C, W, H]，取决于采取哪个配置文件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一次卷积已经把图像尺寸减半</span></span><br><span class="line">            x = self.conv1(x)</span><br><span class="line">            <span class="comment"># 在通道上分成两组，进行分组卷积</span></span><br><span class="line">            x1, x2 = x.chunk(<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># x2先通道翻倍，再分离式卷积（同时分辨率减半），最后通道减半</span></span><br><span class="line">            x2 = self.expand_conv(x2)</span><br><span class="line">            x2 = self.depthwise_conv(x2)</span><br><span class="line">            x2 = self.linear_conv(x2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># x2先经过分离式卷积（同时分辨率减半），再经过1*1卷积通道信息交互（也改变使得通道数+x2的=out要求）</span></span><br><span class="line">            out = torch.cat((self.branch1(x1), x2), dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第二个参数是通道上分组的数量，要求通道放在第二个维度</span></span><br><span class="line">            out = channel_shuffle(out, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.with_cp <span class="keyword">and</span> x.requires_grad:</span><br><span class="line">            out = cp.checkpoint(_inner_forward, x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out = _inner_forward(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最后的4个分辨率融合在一起，输出最大的分辨率</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterativeHead</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, conv_cfg=<span class="literal">None</span>, norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>)</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        projects = []</span><br><span class="line">        num_branchs = <span class="built_in">len</span>(in_channels)</span><br><span class="line">        <span class="comment"># 为了和后续的分辨率反转对应，通道数量也反转了</span></span><br><span class="line">        <span class="comment"># 现在idx=0对应分辨率最低的通道</span></span><br><span class="line">        self.in_channels = in_channels[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_branchs):</span><br><span class="line">            <span class="keyword">if</span> i != num_branchs - <span class="number">1</span>:</span><br><span class="line">                projects.append(</span><br><span class="line">                    DepthwiseSeparableConvModule(</span><br><span class="line">                        in_channels=self.in_channels[i],</span><br><span class="line">                        out_channels=self.in_channels[i + <span class="number">1</span>],</span><br><span class="line">                        kernel_size=<span class="number">3</span>,</span><br><span class="line">                        stride=<span class="number">1</span>,</span><br><span class="line">                        padding=<span class="number">1</span>,</span><br><span class="line">                        norm_cfg=norm_cfg,</span><br><span class="line">                        act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>),</span><br><span class="line">                        dw_act_cfg=<span class="literal">None</span>,</span><br><span class="line">                        pw_act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>)))</span><br><span class="line">            <span class="comment"># 最高分辨率分支通道数量不变</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                projects.append(</span><br><span class="line">                    DepthwiseSeparableConvModule(</span><br><span class="line">                        in_channels=self.in_channels[i],</span><br><span class="line">                        out_channels=self.in_channels[i],</span><br><span class="line">                        kernel_size=<span class="number">3</span>,</span><br><span class="line">                        stride=<span class="number">1</span>,</span><br><span class="line">                        padding=<span class="number">1</span>,</span><br><span class="line">                        norm_cfg=norm_cfg,</span><br><span class="line">                        act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>),</span><br><span class="line">                        dw_act_cfg=<span class="literal">None</span>,</span><br><span class="line">                        pw_act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>)))</span><br><span class="line">        self.projects = nn.ModuleList(projects)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 顺序颠倒，原本x[0]分辨率最高，现在x[3]分辨率最高</span></span><br><span class="line">        x = x[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        y = []</span><br><span class="line">        last_x = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 从低分辨率开始处理起来</span></span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">            <span class="keyword">if</span> last_x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 上一次的特征通道减半，插值来提高分辨率</span></span><br><span class="line">                last_x = F.interpolate(</span><br><span class="line">                    last_x,</span><br><span class="line">                    size=s.size()[-<span class="number">2</span>:],</span><br><span class="line">                    mode=<span class="string">&#x27;bilinear&#x27;</span>,</span><br><span class="line">                    align_corners=<span class="literal">True</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 相加向上融合</span></span><br><span class="line">                s = s + last_x</span><br><span class="line">            <span class="comment"># 分离式卷积变通道</span></span><br><span class="line">            s = self.projects[i](s)</span><br><span class="line">            y.append(s)</span><br><span class="line">            last_x = s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 还原到idx=0对应最高分辨率</span></span><br><span class="line">        <span class="keyword">return</span> y[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># native Lite-HRNet版本才需要</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleUnit</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;InvertedResidual block for ShuffleNetV2 backbone.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        in_channels (int): The input channels of the block.</span></span><br><span class="line"><span class="string">        out_channels (int): The output channels of the block.</span></span><br><span class="line"><span class="string">        stride (int): Stride of the 3x3 convolution layer. Default: 1</span></span><br><span class="line"><span class="string">        conv_cfg (dict): Config dict for convolution layer.</span></span><br><span class="line"><span class="string">            Default: None, which means using conv2d.</span></span><br><span class="line"><span class="string">        norm_cfg (dict): Config dict for normalization layer.</span></span><br><span class="line"><span class="string">            Default: dict(type=&#x27;BN&#x27;).</span></span><br><span class="line"><span class="string">        act_cfg (dict): Config dict for activation layer.</span></span><br><span class="line"><span class="string">            Default: dict(type=&#x27;ReLU&#x27;).</span></span><br><span class="line"><span class="string">        with_cp (bool): Use checkpoint or not. Using checkpoint will save some</span></span><br><span class="line"><span class="string">            memory while slowing down the training speed. Default: False.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 in_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 out_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stride=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                 act_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                 with_cp=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self.with_cp = with_cp</span><br><span class="line"></span><br><span class="line">        branch_features = out_channels // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self.stride == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">assert</span> in_channels == branch_features * <span class="number">2</span>, (</span><br><span class="line">                <span class="string">f&#x27;in_channels (<span class="subst">&#123;in_channels&#125;</span>) should equal to &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;branch_features * 2 (<span class="subst">&#123;branch_features * <span class="number">2</span>&#125;</span>) &#x27;</span></span><br><span class="line">                <span class="string">&#x27;when stride is 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> in_channels != branch_features * <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">assert</span> self.stride != <span class="number">1</span>, (</span><br><span class="line">                <span class="string">f&#x27;stride (<span class="subst">&#123;self.stride&#125;</span>) should not equal 1 when &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;in_channels != branch_features * 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.stride &gt; <span class="number">1</span>:</span><br><span class="line">            self.branch1 = nn.Sequential(</span><br><span class="line">                ConvModule(</span><br><span class="line">                    in_channels,</span><br><span class="line">                    in_channels,</span><br><span class="line">                    kernel_size=<span class="number">3</span>,</span><br><span class="line">                    stride=self.stride,</span><br><span class="line">                    padding=<span class="number">1</span>,</span><br><span class="line">                    groups=in_channels,</span><br><span class="line">                    conv_cfg=conv_cfg,</span><br><span class="line">                    norm_cfg=norm_cfg,</span><br><span class="line">                    act_cfg=<span class="literal">None</span>),</span><br><span class="line">                ConvModule(</span><br><span class="line">                    in_channels,</span><br><span class="line">                    branch_features,</span><br><span class="line">                    kernel_size=<span class="number">1</span>,</span><br><span class="line">                    stride=<span class="number">1</span>,</span><br><span class="line">                    padding=<span class="number">0</span>,</span><br><span class="line">                    conv_cfg=conv_cfg,</span><br><span class="line">                    norm_cfg=norm_cfg,</span><br><span class="line">                    act_cfg=act_cfg),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self.branch2 = nn.Sequential(</span><br><span class="line">            ConvModule(</span><br><span class="line">                in_channels <span class="keyword">if</span> (self.stride &gt; <span class="number">1</span>) <span class="keyword">else</span> branch_features,</span><br><span class="line">                branch_features,</span><br><span class="line">                kernel_size=<span class="number">1</span>,</span><br><span class="line">                stride=<span class="number">1</span>,</span><br><span class="line">                padding=<span class="number">0</span>,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=act_cfg),</span><br><span class="line">            ConvModule(</span><br><span class="line">                branch_features,</span><br><span class="line">                branch_features,</span><br><span class="line">                kernel_size=<span class="number">3</span>,</span><br><span class="line">                stride=self.stride,</span><br><span class="line">                padding=<span class="number">1</span>,</span><br><span class="line">                groups=branch_features,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=<span class="literal">None</span>),</span><br><span class="line">            ConvModule(</span><br><span class="line">                branch_features,</span><br><span class="line">                branch_features,</span><br><span class="line">                kernel_size=<span class="number">1</span>,</span><br><span class="line">                stride=<span class="number">1</span>,</span><br><span class="line">                padding=<span class="number">0</span>,</span><br><span class="line">                conv_cfg=conv_cfg,</span><br><span class="line">                norm_cfg=norm_cfg,</span><br><span class="line">                act_cfg=act_cfg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_inner_forward</span>(<span class="params">x</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.stride &gt; <span class="number">1</span>:</span><br><span class="line">                out = torch.cat((self.branch1(x), self.branch2(x)), dim=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x1, x2 = x.chunk(<span class="number">2</span>, dim=<span class="number">1</span>)</span><br><span class="line">                out = torch.cat((x1, self.branch2(x2)), dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            out = channel_shuffle(out, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.with_cp <span class="keyword">and</span> x.requires_grad:</span><br><span class="line">            out = cp.checkpoint(_inner_forward, x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out = _inner_forward(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiteHRModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            num_branches,</span></span></span><br><span class="line"><span class="function"><span class="params">            num_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">            in_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">            reduce_ratio,</span></span></span><br><span class="line"><span class="function"><span class="params">            module_type,</span></span></span><br><span class="line"><span class="function"><span class="params">            multiscale_output=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            with_fuse=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">            with_cp=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._check_branches(num_branches, in_channels)</span><br><span class="line"></span><br><span class="line">        self.in_channels = in_channels</span><br><span class="line">        self.num_branches = num_branches</span><br><span class="line"></span><br><span class="line">        self.module_type = module_type</span><br><span class="line">        self.multiscale_output = multiscale_output</span><br><span class="line">        self.with_fuse = with_fuse</span><br><span class="line">        self.norm_cfg = norm_cfg</span><br><span class="line">        self.conv_cfg = conv_cfg</span><br><span class="line">        self.with_cp = with_cp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.module_type == <span class="string">&#x27;LITE&#x27;</span>:</span><br><span class="line">            <span class="comment"># 先构建权重模块，权重模块的数量由num_blocks决定</span></span><br><span class="line">            self.layers = self._make_weighting_blocks(num_blocks, reduce_ratio)</span><br><span class="line">        <span class="keyword">elif</span> self.module_type == <span class="string">&#x27;NAIVE&#x27;</span>:</span><br><span class="line">            self.layers = self._make_naive_branches(num_branches, num_blocks)</span><br><span class="line">        <span class="keyword">if</span> self.with_fuse:</span><br><span class="line">            self.fuse_layers = self._make_fuse_layers()</span><br><span class="line">            self.relu = nn.ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_branches</span>(<span class="params">self, num_branches, in_channels</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Check input to avoid ValueError.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num_branches != <span class="built_in">len</span>(in_channels):</span><br><span class="line">            error_msg = <span class="string">f&#x27;NUM_BRANCHES(<span class="subst">&#123;num_branches&#125;</span>) &#x27;</span> \</span><br><span class="line">                <span class="string">f&#x27;!= NUM_INCHANNELS(<span class="subst">&#123;<span class="built_in">len</span>(in_channels)&#125;</span>)&#x27;</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(error_msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_weighting_blocks</span>(<span class="params">self, num_blocks, reduce_ratio, stride=<span class="number">1</span></span>):</span></span><br><span class="line">        layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_blocks):</span><br><span class="line">            layers.append(</span><br><span class="line">                ConditionalChannelWeighting(</span><br><span class="line">                    self.in_channels,</span><br><span class="line">                    stride=stride,</span><br><span class="line">                    reduce_ratio=reduce_ratio,</span><br><span class="line">                    conv_cfg=self.conv_cfg,</span><br><span class="line">                    norm_cfg=self.norm_cfg,</span><br><span class="line">                    with_cp=self.with_cp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># native版本才需要</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_one_branch</span>(<span class="params">self, branch_index, num_blocks, stride=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make one branch.&quot;&quot;&quot;</span></span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(</span><br><span class="line">            ShuffleUnit(</span><br><span class="line">                self.in_channels[branch_index],</span><br><span class="line">                self.in_channels[branch_index],</span><br><span class="line">                stride=stride,</span><br><span class="line">                conv_cfg=self.conv_cfg,</span><br><span class="line">                norm_cfg=self.norm_cfg,</span><br><span class="line">                act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>),</span><br><span class="line">                with_cp=self.with_cp))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_blocks):</span><br><span class="line">            layers.append(</span><br><span class="line">                ShuffleUnit(</span><br><span class="line">                    self.in_channels[branch_index],</span><br><span class="line">                    self.in_channels[branch_index],</span><br><span class="line">                    stride=<span class="number">1</span>,</span><br><span class="line">                    conv_cfg=self.conv_cfg,</span><br><span class="line">                    norm_cfg=self.norm_cfg,</span><br><span class="line">                    act_cfg=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">&#x27;ReLU&#x27;</span>),</span><br><span class="line">                    with_cp=self.with_cp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_naive_branches</span>(<span class="params">self, num_branches, num_blocks</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make branches.&quot;&quot;&quot;</span></span><br><span class="line">        branches = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_branches):</span><br><span class="line">            branches.append(self._make_one_branch(i, num_blocks))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nn.ModuleList(branches)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 融合层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_fuse_layers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make fuse layer.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.num_branches == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        num_branches = self.num_branches</span><br><span class="line">        in_channels = self.in_channels</span><br><span class="line">        fuse_layers = []</span><br><span class="line">        num_out_branches = num_branches <span class="keyword">if</span> self.multiscale_output <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 外层遍历每个brach num_out_branches = num_branches</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_out_branches):</span><br><span class="line">            fuse_layer = []</span><br><span class="line">            <span class="comment"># 对于第i个brach，融合第j个brach的信息</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_branches):</span><br><span class="line">                <span class="comment"># 从低分辨率到高分辨率需要1*1卷积来变通道+上采样</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i:</span><br><span class="line">                    fuse_layer.append(</span><br><span class="line">                        nn.Sequential(</span><br><span class="line">                            build_conv_layer(</span><br><span class="line">                                self.conv_cfg,</span><br><span class="line">                                in_channels[j],</span><br><span class="line">                                in_channels[i],</span><br><span class="line">                                kernel_size=<span class="number">1</span>,</span><br><span class="line">                                stride=<span class="number">1</span>,</span><br><span class="line">                                padding=<span class="number">0</span>,</span><br><span class="line">                                bias=<span class="literal">False</span>),</span><br><span class="line">                            build_norm_layer(self.norm_cfg, in_channels[i])[<span class="number">1</span>],</span><br><span class="line">                            nn.Upsample(</span><br><span class="line">                                scale_factor=<span class="number">2</span>**(j - i), mode=<span class="string">&#x27;nearest&#x27;</span>)))</span><br><span class="line">                <span class="comment"># 同分辨率不处理</span></span><br><span class="line">                <span class="keyword">elif</span> j == i:</span><br><span class="line">                    fuse_layer.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 高分辨率到低分辨率需要i-j次下采样</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    conv_downsamples = []</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i - j):</span><br><span class="line">                        <span class="comment"># 最后一次下采样进行了通道调整，同时没有relu层</span></span><br><span class="line">                        <span class="keyword">if</span> k == i - j - <span class="number">1</span>:</span><br><span class="line">                            conv_downsamples.append(</span><br><span class="line">                                nn.Sequential(</span><br><span class="line">                                    build_conv_layer(</span><br><span class="line">                                        self.conv_cfg,</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        kernel_size=<span class="number">3</span>,</span><br><span class="line">                                        stride=<span class="number">2</span>,</span><br><span class="line">                                        padding=<span class="number">1</span>,</span><br><span class="line">                                        groups=in_channels[j],</span><br><span class="line">                                        bias=<span class="literal">False</span>),</span><br><span class="line">                                    build_norm_layer(self.norm_cfg,</span><br><span class="line">                                                     in_channels[j])[<span class="number">1</span>],</span><br><span class="line">                                    build_conv_layer(</span><br><span class="line">                                        self.conv_cfg,</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        in_channels[i],</span><br><span class="line">                                        kernel_size=<span class="number">1</span>,</span><br><span class="line">                                        stride=<span class="number">1</span>,</span><br><span class="line">                                        padding=<span class="number">0</span>,</span><br><span class="line">                                        bias=<span class="literal">False</span>),</span><br><span class="line">                                    build_norm_layer(self.norm_cfg,</span><br><span class="line">                                                     in_channels[i])[<span class="number">1</span>]))</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            conv_downsamples.append(</span><br><span class="line">                                nn.Sequential(</span><br><span class="line">                                    build_conv_layer(</span><br><span class="line">                                        self.conv_cfg,</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        kernel_size=<span class="number">3</span>,</span><br><span class="line">                                        stride=<span class="number">2</span>,</span><br><span class="line">                                        padding=<span class="number">1</span>,</span><br><span class="line">                                        groups=in_channels[j],</span><br><span class="line">                                        bias=<span class="literal">False</span>),</span><br><span class="line">                                    build_norm_layer(self.norm_cfg,</span><br><span class="line">                                                     in_channels[j])[<span class="number">1</span>],</span><br><span class="line">                                    build_conv_layer(</span><br><span class="line">                                        self.conv_cfg,</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        in_channels[j],</span><br><span class="line">                                        kernel_size=<span class="number">1</span>,</span><br><span class="line">                                        stride=<span class="number">1</span>,</span><br><span class="line">                                        padding=<span class="number">0</span>,</span><br><span class="line">                                        bias=<span class="literal">False</span>),</span><br><span class="line">                                    build_norm_layer(self.norm_cfg,</span><br><span class="line">                                                     in_channels[j])[<span class="number">1</span>],</span><br><span class="line">                                    nn.ReLU(inplace=<span class="literal">True</span>)))</span><br><span class="line">                    fuse_layer.append(nn.Sequential(*conv_downsamples))</span><br><span class="line">            fuse_layers.append(nn.ModuleList(fuse_layer))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nn.ModuleList(fuse_layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Forward function.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.num_branches == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [self.layers[<span class="number">0</span>](x[<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先通过权重模块，每个stage权重模块的数量由num_blocks决定</span></span><br><span class="line">        <span class="keyword">if</span> self.module_type == <span class="string">&#x27;LITE&#x27;</span>:</span><br><span class="line">            out = self.layers(x)</span><br><span class="line">        <span class="keyword">elif</span> self.module_type == <span class="string">&#x27;NAIVE&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_branches):</span><br><span class="line">                x[i] = self.layers[i](x[i])</span><br><span class="line">            out = x</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 权重模块之后进行融合</span></span><br><span class="line">        <span class="keyword">if</span> self.with_fuse:</span><br><span class="line">            out_fuse = []</span><br><span class="line">            <span class="comment"># 对于分支i的融合</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.fuse_layers)):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 设置初值，但是感觉这里第0个分支的特征被融合了两次？</span></span><br><span class="line">                y = out[<span class="number">0</span>] <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">else</span> self.fuse_layers[i][<span class="number">0</span>](out[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 把out[j]特征融合到out[i]上</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.num_branches):</span><br><span class="line">                    <span class="comment"># 相等的时候原本layer会为None,这里没用过None来判断</span></span><br><span class="line">                    <span class="keyword">if</span> i == j:</span><br><span class="line">                        y += out[j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        y += self.fuse_layers[i][j](out[j])</span><br><span class="line">                out_fuse.append(self.relu(y))</span><br><span class="line">            out = out_fuse</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> self.multiscale_output:</span><br><span class="line">            out = [out[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@BACKBONES.register_module()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiteHRNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Lite-HRNet backbone.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `High-Resolution Representations for Labeling Pixels and Regions</span></span><br><span class="line"><span class="string">    &lt;https://arxiv.org/abs/1904.04514&gt;`_</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        extra (dict): detailed configuration for each stage of HRNet.</span></span><br><span class="line"><span class="string">        in_channels (int): Number of input image channels. Default: 3.</span></span><br><span class="line"><span class="string">        conv_cfg (dict): dictionary to construct and config conv layer.</span></span><br><span class="line"><span class="string">        norm_cfg (dict): dictionary to construct and config norm layer.</span></span><br><span class="line"><span class="string">        norm_eval (bool): Whether to set norm layers to eval mode, namely,</span></span><br><span class="line"><span class="string">            freeze running stats (mean and var). Note: Effect on Batch Norm</span></span><br><span class="line"><span class="string">            and its variants only. Default: False</span></span><br><span class="line"><span class="string">        with_cp (bool): Use checkpoint or not. Using checkpoint will save some</span></span><br><span class="line"><span class="string">            memory while slowing down the training speed.</span></span><br><span class="line"><span class="string">        zero_init_residual (bool): whether to use zero init for last norm layer</span></span><br><span class="line"><span class="string">            in resblocks to let them behave as identity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; from mmpose.models import HRNet</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; import torch</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; extra = dict(</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;     stage1=dict(</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_modules=1,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_branches=1,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         block=&#x27;BOTTLENECK&#x27;,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_blocks=(4, ),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_channels=(64, )),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;     stage2=dict(</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_modules=1,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_branches=2,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         block=&#x27;BASIC&#x27;,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_blocks=(4, 4),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_channels=(32, 64)),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;     stage3=dict(</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_modules=4,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_branches=3,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         block=&#x27;BASIC&#x27;,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_blocks=(4, 4, 4),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_channels=(32, 64, 128)),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;     stage4=dict(</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_modules=3,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_branches=4,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         block=&#x27;BASIC&#x27;,</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_blocks=(4, 4, 4, 4),</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt;         num_channels=(32, 64, 128, 256)))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; self = HRNet(extra, in_channels=1)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; self.eval()</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; inputs = torch.rand(1, 1, 32, 32)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; level_outputs = self.forward(inputs)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; for level_out in level_outputs:</span></span><br><span class="line"><span class="string">        ...     print(tuple(level_out.shape))</span></span><br><span class="line"><span class="string">        (1, 32, 8, 8)</span></span><br><span class="line"><span class="string">        (1, 64, 4, 4)</span></span><br><span class="line"><span class="string">        (1, 128, 2, 2)</span></span><br><span class="line"><span class="string">        (1, 256, 1, 1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 extra,</span></span></span><br><span class="line"><span class="function"><span class="params">                 in_channels=<span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 conv_cfg=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_cfg=<span class="built_in">dict</span>(<span class="params"><span class="built_in">type</span>=<span class="string">&#x27;BN&#x27;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                 norm_eval=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 with_cp=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 zero_init_residual=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.extra = extra</span><br><span class="line">        self.conv_cfg = conv_cfg</span><br><span class="line">        self.norm_cfg = norm_cfg</span><br><span class="line">        self.norm_eval = norm_eval</span><br><span class="line">        self.with_cp = with_cp</span><br><span class="line">        self.zero_init_residual = zero_init_residual</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上述的help部分的extra参数写的有问题，少了一些参数配置</span></span><br><span class="line">        <span class="comment"># 现在的代码从config文件中读取配置没问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Stem使用shuffle块来完成特征提取，叫做Stem部分！提取后分辨率是原来0.25</span></span><br><span class="line">        self.stem = Stem(</span><br><span class="line">            in_channels,</span><br><span class="line">            stem_channels=self.extra[<span class="string">&#x27;stem&#x27;</span>][<span class="string">&#x27;stem_channels&#x27;</span>],</span><br><span class="line">            out_channels=self.extra[<span class="string">&#x27;stem&#x27;</span>][<span class="string">&#x27;out_channels&#x27;</span>],</span><br><span class="line">            expand_ratio=self.extra[<span class="string">&#x27;stem&#x27;</span>][<span class="string">&#x27;expand_ratio&#x27;</span>],</span><br><span class="line">            conv_cfg=self.conv_cfg,</span><br><span class="line">            norm_cfg=self.norm_cfg)</span><br><span class="line"></span><br><span class="line">        self.num_stages = self.extra[<span class="string">&#x27;num_stages&#x27;</span>]</span><br><span class="line">        self.stages_spec = self.extra[<span class="string">&#x27;stages_spec&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        num_channels_last = [</span><br><span class="line">            self.stem.out_channels,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 首先将3个stage构建好，每个stage由make_transition和make_stage构成</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_stages):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每个stage分为两部分，make transition + make stage</span></span><br><span class="line">            num_channels = self.stages_spec[<span class="string">&#x27;num_channels&#x27;</span>][i]</span><br><span class="line">            num_channels = [num_channels[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num_channels))]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每个transistion从前一个stage过度到新的stage所需要的层</span></span><br><span class="line">            <span class="built_in">setattr</span>(</span><br><span class="line">                self, <span class="string">&#x27;transition&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">                self._make_transition_layer(num_channels_last, num_channels))</span><br><span class="line"></span><br><span class="line">            stage, num_channels_last = self._make_stage(</span><br><span class="line">                self.stages_spec, i, num_channels, multiscale_output=<span class="literal">True</span>)</span><br><span class="line">            <span class="built_in">setattr</span>(self, <span class="string">&#x27;stage&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i), stage)</span><br><span class="line"></span><br><span class="line">        self.with_head = self.extra[<span class="string">&#x27;with_head&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 同时先构建好IterativeHead层</span></span><br><span class="line">        <span class="keyword">if</span> self.with_head:</span><br><span class="line">            self.head_layer = IterativeHead(</span><br><span class="line">                in_channels=num_channels_last,</span><br><span class="line">                conv_cfg=self.conv_cfg,</span><br><span class="line">                norm_cfg=self.norm_cfg,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_transition_layer</span>(<span class="params">self, num_channels_pre_layer,</span></span></span><br><span class="line"><span class="function"><span class="params">                               num_channels_cur_layer</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Make transition layer.&quot;&quot;&quot;</span></span><br><span class="line">        num_branches_cur = <span class="built_in">len</span>(num_channels_cur_layer)</span><br><span class="line">        num_branches_pre = <span class="built_in">len</span>(num_channels_pre_layer)</span><br><span class="line"></span><br><span class="line">        transition_layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_branches_cur):</span><br><span class="line">            <span class="comment"># 继承先前分辨率的分支 包含 不变+上采样/下采样 的两种情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># transition的时候感觉没有做融合？</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; num_branches_pre:</span><br><span class="line">                <span class="comment"># 如果当前分支和前一个分支相比通道数量变了</span></span><br><span class="line">                <span class="comment"># 则使用 分离式卷积 + 1*1卷积 处理</span></span><br><span class="line">                <span class="keyword">if</span> num_channels_cur_layer[i] != num_channels_pre_layer[i]:</span><br><span class="line">                    transition_layers.append(</span><br><span class="line">                        nn.Sequential(</span><br><span class="line">                            build_conv_layer(</span><br><span class="line">                                self.conv_cfg,</span><br><span class="line">                                num_channels_pre_layer[i],</span><br><span class="line">                                num_channels_pre_layer[i],</span><br><span class="line">                                kernel_size=<span class="number">3</span>,</span><br><span class="line">                                stride=<span class="number">1</span>,</span><br><span class="line">                                padding=<span class="number">1</span>,</span><br><span class="line">                                groups=num_channels_pre_layer[i],</span><br><span class="line">                                bias=<span class="literal">False</span>),</span><br><span class="line">                            build_norm_layer(self.norm_cfg,</span><br><span class="line">                                             num_channels_pre_layer[i])[<span class="number">1</span>],</span><br><span class="line">                            build_conv_layer(</span><br><span class="line">                                self.conv_cfg,</span><br><span class="line">                                num_channels_pre_layer[i],</span><br><span class="line">                                num_channels_cur_layer[i],</span><br><span class="line">                                kernel_size=<span class="number">1</span>,</span><br><span class="line">                                stride=<span class="number">1</span>,</span><br><span class="line">                                padding=<span class="number">0</span>,</span><br><span class="line">                                bias=<span class="literal">False</span>),</span><br><span class="line">                            build_norm_layer(self.norm_cfg,</span><br><span class="line">                                             num_channels_cur_layer[i])[<span class="number">1</span>],</span><br><span class="line">                            nn.ReLU()))</span><br><span class="line">                <span class="comment"># 如果通道数量没有变化，则不添加层来处理，对应层设置为None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    transition_layers.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># 新生成分辨率的分支的做法 只包含下采样</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                conv_downsamples = []</span><br><span class="line">                <span class="comment"># 对于每个新的分辨率，这里写的感觉是只由前面最低的分辨率生成？</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span> - num_branches_pre):</span><br><span class="line">                    in_channels = num_channels_pre_layer[-<span class="number">1</span>]</span><br><span class="line">                    out_channels = num_channels_cur_layer[i] \</span><br><span class="line">                        <span class="keyword">if</span> j == i - num_branches_pre <span class="keyword">else</span> in_channels</span><br><span class="line">                    conv_downsamples.append(</span><br><span class="line">                        nn.Sequential(</span><br><span class="line">                            build_conv_layer(</span><br><span class="line">                                self.conv_cfg,</span><br><span class="line">                                in_channels,</span><br><span class="line">                                in_channels,</span><br><span class="line">                                kernel_size=<span class="number">3</span>,</span><br><span class="line">                                stride=<span class="number">2</span>,</span><br><span class="line">                                padding=<span class="number">1</span>,</span><br><span class="line">                                groups=in_channels,</span><br><span class="line">                                bias=<span class="literal">False</span>),</span><br><span class="line">                            build_norm_layer(self.norm_cfg, in_channels)[<span class="number">1</span>],</span><br><span class="line">                            build_conv_layer(</span><br><span class="line">                                self.conv_cfg,</span><br><span class="line">                                in_channels,</span><br><span class="line">                                out_channels,</span><br><span class="line">                                kernel_size=<span class="number">1</span>,</span><br><span class="line">                                stride=<span class="number">1</span>,</span><br><span class="line">                                padding=<span class="number">0</span>,</span><br><span class="line">                                bias=<span class="literal">False</span>),</span><br><span class="line">                            build_norm_layer(self.norm_cfg, out_channels)[<span class="number">1</span>],</span><br><span class="line">                            nn.ReLU()))</span><br><span class="line"></span><br><span class="line">                transition_layers.append(nn.Sequential(*conv_downsamples))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nn.ModuleList(transition_layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_stage</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="function"><span class="params">                    stages_spec,</span></span></span><br><span class="line"><span class="function"><span class="params">                    stage_index,</span></span></span><br><span class="line"><span class="function"><span class="params">                    in_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                    multiscale_output=<span class="literal">True</span></span>):</span></span><br><span class="line">        num_modules = stages_spec[<span class="string">&#x27;num_modules&#x27;</span>][stage_index]</span><br><span class="line">        num_branches = stages_spec[<span class="string">&#x27;num_branches&#x27;</span>][stage_index]</span><br><span class="line">        num_blocks = stages_spec[<span class="string">&#x27;num_blocks&#x27;</span>][stage_index]</span><br><span class="line">        reduce_ratio = stages_spec[<span class="string">&#x27;reduce_ratios&#x27;</span>][stage_index]</span><br><span class="line">        with_fuse = stages_spec[<span class="string">&#x27;with_fuse&#x27;</span>][stage_index]</span><br><span class="line">        module_type = stages_spec[<span class="string">&#x27;module_type&#x27;</span>][stage_index]</span><br><span class="line"></span><br><span class="line">        modules = []</span><br><span class="line">        <span class="comment"># make stage部分内部的融合实现</span></span><br><span class="line">        <span class="comment"># 每个stage都有很多个LiteHRModule，同时每个LiteHRModule内部包含num_blocks个</span></span><br><span class="line">        <span class="comment"># 论文中的权重块 + fusion_layer</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_modules):</span><br><span class="line">            <span class="comment"># multi_scale_output is only used last module</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> multiscale_output <span class="keyword">and</span> i == num_modules - <span class="number">1</span>:</span><br><span class="line">                reset_multiscale_output = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reset_multiscale_output = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            modules.append(</span><br><span class="line">                LiteHRModule(</span><br><span class="line">                    num_branches,</span><br><span class="line">                    num_blocks,</span><br><span class="line">                    in_channels,</span><br><span class="line">                    reduce_ratio,</span><br><span class="line">                    module_type,</span><br><span class="line">                    multiscale_output=reset_multiscale_output,</span><br><span class="line">                    with_fuse=with_fuse,</span><br><span class="line">                    conv_cfg=self.conv_cfg,</span><br><span class="line">                    norm_cfg=self.norm_cfg,</span><br><span class="line">                    with_cp=self.with_cp))</span><br><span class="line">            in_channels = modules[-<span class="number">1</span>].in_channels</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*modules), in_channels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">self, pretrained=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize the weights in backbone.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            pretrained (str, optional): Path to pre-trained weights.</span></span><br><span class="line"><span class="string">                Defaults to None.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(pretrained, <span class="built_in">str</span>):</span><br><span class="line">            logger = get_root_logger()</span><br><span class="line">            load_checkpoint(self, pretrained, strict=<span class="literal">False</span>, logger=logger)</span><br><span class="line">        <span class="keyword">elif</span> pretrained <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                    normal_init(m, std=<span class="number">0.001</span>)</span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, (_BatchNorm, nn.GroupNorm)):</span><br><span class="line">                    constant_init(m, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.zero_init_residual:</span><br><span class="line">                <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, Bottleneck):</span><br><span class="line">                        constant_init(m.norm3, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, BasicBlock):</span><br><span class="line">                        constant_init(m.norm2, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;pretrained must be a str or None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Forward function.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取embedding, 提取后分辨率变为原来0.25</span></span><br><span class="line">        x = self.stem(x)</span><br><span class="line"></span><br><span class="line">        y_list = [x]</span><br><span class="line">        <span class="comment"># 外层循环是每个stage</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_stages):</span><br><span class="line">            x_list = []</span><br><span class="line">            <span class="comment"># 等效于self.transition0, ..., 与__init__中的setattr对照</span></span><br><span class="line">            transition = <span class="built_in">getattr</span>(self, <span class="string">&#x27;transition&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="comment"># 内层循环是每个分支，transition部分其实每个分支之间是独立的，不是图中</span></span><br><span class="line">            <span class="comment"># 画的那样有融合？</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.stages_spec[<span class="string">&#x27;num_branches&#x27;</span>][i]):</span><br><span class="line">                <span class="comment"># 如果不为None需要变换，通道不变的原分辨率分支直接拉过来,是None</span></span><br><span class="line">                <span class="keyword">if</span> transition[j]:</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= <span class="built_in">len</span>(y_list):</span><br><span class="line">                        x_list.append(transition[j](y_list[-<span class="number">1</span>]))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        x_list.append(transition[j](y_list[j]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x_list.append(y_list[j])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># transition使用stage层，同时更新y_list</span></span><br><span class="line">            <span class="comment"># stage层用到了LiteHRModule</span></span><br><span class="line">            y_list = <span class="built_in">getattr</span>(self, <span class="string">&#x27;stage&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))(x_list)</span><br><span class="line"></span><br><span class="line">        x = y_list</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到了4个分辨率的特征图，x[0]分辨率最大，x[3]分辨率最小</span></span><br><span class="line">        <span class="comment"># 分辨率和通道数量都是2的倍数关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 是将多个分辨率融合在一起，还是直接输出最高的分辨率</span></span><br><span class="line">        <span class="keyword">if</span> self.with_head:</span><br><span class="line">            x = self.head_layer(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, mode=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Convert the model into training mode.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().train(mode)</span><br><span class="line">        <span class="keyword">if</span> mode <span class="keyword">and</span> self.norm_eval:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, _BatchNorm):</span><br><span class="line">                    m.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><h4 id="将Lite-HRNet模块注册到mmpose"><a href="#将Lite-HRNet模块注册到mmpose" class="headerlink" title="将Lite-HRNet模块注册到mmpose"></a>将Lite-HRNet模块注册到mmpose</h4><p>1.按照mmpose官方教程<a href="https://github.com/open-mmlab/mmpose/blob/master/docs/install.md%E5%85%88%E5%AE%89%E8%A3%85%E5%A5%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BA%93%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8opencv%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85%E4%B8%8Bopencv-contrib-python">https://github.com/open-mmlab/mmpose/blob/master/docs/install.md先安装好相关的库，但是可能使用opencv会报错，需要先安装下opencv-contrib-python</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-contrib-python</span><br></pre></td></tr></table></figure><p>安装好mmpose所依赖的库之后，先不要运行<code>python setup.py develop</code>，因为需要先把Lite-HRNet的代码（上面的代码）放到mmpose项目中进行注册才有使用。</p><p>2.git clone整个mmpose库到本地后，将Lite-HRNet/models/backbones/litehrnet.py中开头的几个import进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mmpose.models.registry <span class="keyword">import</span> BACKBONES</span><br><span class="line"><span class="keyword">from</span> mmpose.models.backbones.resnet <span class="keyword">import</span> BasicBlock, Bottleneck</span><br><span class="line"><span class="keyword">from</span> mmpose.models.backbones.utils <span class="keyword">import</span> load_checkpoint, channel_shuffle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为如下：</span></span><br><span class="line"><span class="keyword">from</span> ..registry <span class="keyword">import</span> BACKBONES</span><br><span class="line"><span class="keyword">from</span> .resnet <span class="keyword">import</span> BasicBlock, Bottleneck</span><br><span class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> load_checkpoint, channel_shuffle</span><br></pre></td></tr></table></figure><p>然后将修改后的litehrnet.py放到mmpose项目的mmpose/mmpose/models/backbones/目录下，并在mmpose/mmpose/models/backbones/__init__.py中注册LiteHRNet模块，即在mmpose/mmpose/models/backbones/__init__.py增加和修改如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .litehrnet <span class="keyword">import</span> LiteHRNet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># all中添加LiteHRNet</span></span><br><span class="line">__all__ = [</span><br><span class="line">    <span class="string">&#x27;AlexNet&#x27;</span>, <span class="string">&#x27;HourglassNet&#x27;</span>, <span class="string">&#x27;HRNet&#x27;</span>, <span class="string">&#x27;LiteHRNet&#x27;</span>, <span class="string">&#x27;MobileNetV2&#x27;</span>, <span class="string">&#x27;MobileNetV3&#x27;</span>, <span class="string">&#x27;RegNet&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ResNet&#x27;</span>, <span class="string">&#x27;ResNetV1d&#x27;</span>, <span class="string">&#x27;ResNeXt&#x27;</span>, <span class="string">&#x27;SCNet&#x27;</span>, <span class="string">&#x27;SEResNet&#x27;</span>, <span class="string">&#x27;SEResNeXt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ShuffleNetV1&#x27;</span>, <span class="string">&#x27;ShuffleNetV2&#x27;</span>, <span class="string">&#x27;CPM&#x27;</span>, <span class="string">&#x27;RSN&#x27;</span>, <span class="string">&#x27;MSPN&#x27;</span>, <span class="string">&#x27;ResNeSt&#x27;</span>, <span class="string">&#x27;VGG&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;TCN&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3.按照官方安装教程安装运行<code>python setup.py develop</code>，这样后续就能使用商汤的demo来调用LiteHRNet。</p><p>4.按照官方教程运行姿态跟踪的demo  <a href="https://github.com/open-mmlab/mmpose/blob/master/demo/docs/2d_pose_tracking_demo.md">mmpose/2d_pose_tracking_demo.md at master · open-mmlab/mmpose (github.com)</a>。需要先进入mmpose项目根目录下，因为mmpose安装在本地的位置，没有到python解释器的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo/top_down_video_demo_with_mmdet.py demo/mmdetection_cfg/faster_rcnn_r50_fpn_coco.py your_faster_rcnn_path/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth your_litehrnet_config/litehrnet_30_coco_384x288.py your_litehrnet_path/litehrnet_stem_32_s3_module_383_b2_fuse_reduce_8_w40_320_head_bs32_lr2e-3_aug_r30s25_val_gtbox_coco_384x288.pth --video-path your_src_video_path/wind.mp4 --out-video-root your_dest_video_root</span><br></pre></td></tr></table></figure><p>其中faster-rcnn按照官方提供地址下载到本地即可<a href="http://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth%EF%BC%8C%E5%A7%BF%E6%80%81%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%B0%B1%E9%80%89%E6%8B%A9LiteHRNet%E9%A1%B9%E7%9B%AELite-HRNet/configs/top_down/lite_hrnet/coco/litehrnet_30_coco_384x288.py%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%AF%B9%E5%BA%94%E7%9A%84ckpt%E4%BB%A3%E7%A0%81%E5%8F%82%E6%95%B0%E6%96%87%E4%BB%B6%E5%8D%B3%E5%8F%AF">http://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth，姿态检测的网络配置参数就选择LiteHRNet项目Lite-HRNet/configs/top_down/lite_hrnet/coco/litehrnet_30_coco_384x288.py文件，并使用对应的ckpt代码参数文件即可</a>:</p><p>onedirve地址<a href="https://1drv.ms/u/s!AvreNzlRJaHneJJYbKPmep86U3o?e=pbBP5B">https://1drv.ms/u/s!AvreNzlRJaHneJJYbKPmep86U3o?e=pbBP5B</a></p><p>googledrive地址<a href="https://drive.google.com/file/d/1nx7AT1DMJRuiYNPcI7EqBp6yJN63ewE1/view?usp=sharing">https://drive.google.com/file/d/1nx7AT1DMJRuiYNPcI7EqBp6yJN63ewE1/view?usp=sharing</a></p><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p>最后是视频效果，这里给出我的视频中一张图片效果</p><div style="text-align: center"><img src="/assets/blog/cd105779/lite_keypoints.jpg" margin="0 auto" width="50%" height="50%"/></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lite-HRNet是开高效姿态估计算法，只有20多M参数，放到移动设备上很方便。&lt;/p&gt;</summary>
    
    
    
    
    <category term="姿态估计" scheme="http://xkwang.cn/tags/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>face++进行姿态估计</title>
    <link href="http://xkwang.cn/post/87cfe86f.html"/>
    <id>http://xkwang.cn/post/87cfe86f.html</id>
    <published>2021-04-25T13:32:23.000Z</published>
    <updated>2021-04-25T13:36:09.281Z</updated>
    
    <content type="html"><![CDATA[<p>从视频中提取图片（cv2）–&gt;调用face++的api返回json数据（posts）–&gt;骨骼线描绘–&gt;图片和mp3重组为mp4（moviepy）</p><a id="more"></a><h4 id="face-API调用"><a href="#face-API调用" class="headerlink" title="face++ API调用"></a>face++ API调用</h4><p><a href="https://console.faceplusplus.com.cn/dashboard">Face⁺⁺ (faceplusplus.com.cn)</a>里面有很多旷世提供的AI算法调用的API，只需要通过post请求就能得到结果。本次实验调用旷世的人体关键点检测API，文档见<a href="https://console.faceplusplus.com.cn/documents/37664576">Face⁺⁺ - 文档中心 (faceplusplus.com.cn)</a>。在调用face++的API文档前，需要先申请一个api_key和api_secret。</p><h4 id="视频预处理"><a href="#视频预处理" class="headerlink" title="视频预处理"></a>视频预处理</h4><p>本次对一个视频进行逐帧的关键点检测，需要先将视频处理成图片，同时后续需要将处理好的推按重新组合成视频，这里选择moviepy库和cv2库来处理。</p><p>首先是从视频中提取图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 调整图片的分辨率大小</span></span><br><span class="line">NEW_SIZE = [<span class="number">720</span>, <span class="number">1280</span>]</span><br><span class="line"><span class="comment"># 设置音频的采样率</span></span><br><span class="line">audio_fps = <span class="number">48000</span></span><br><span class="line"></span><br><span class="line">video = VideoFileClip(<span class="string">&#x27;wind.mp4&#x27;</span>, target_resolution=NEW_SIZE, audio_fps=audio_fps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取音频部分并保存</span></span><br><span class="line">audio = video.audio</span><br><span class="line">audio.write_audiofile(<span class="string">&#x27;wind.mp3&#x27;</span>, fps=<span class="literal">None</span>, bitrate=<span class="string">&#x27;315k&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将修改分辨率的视频重新保存，并设置比特率调整压缩程度</span></span><br><span class="line">video.write_videofile(<span class="string">&#x27;new_wind.mp4&#x27;</span>, bitrate=<span class="string">&#x27;2590k&#x27;</span>, audio_fps=<span class="literal">None</span>, audio_bitrate=<span class="string">&#x27;315k&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从视频中逐帧读取图片并保存</span></span><br><span class="line">videoCapture = cv2.VideoCapture(<span class="string">&#x27;new_wind.mp4&#x27;</span>)</span><br><span class="line">sucess, frame = videoCapture.read()</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> sucess:</span><br><span class="line">i = i+<span class="number">1</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;img/%05d.jpg&#x27;</span>%i, frame)</span><br><span class="line">sucess, frame = videoCapture.read()</span><br></pre></td></tr></table></figure><p>使用moviepy库能够实现音视频的剪辑任务，如将一段无声视频和音频组合起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> moviepy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">video = VideoFileClip(<span class="string">&#x27;test.mp4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">audio = AudioFileClip(<span class="string">&#x27;test.mp3&#x27;</span>, fps=<span class="number">48000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须要使用新的变量来承接改变后的视频，原始的video不会改变</span></span><br><span class="line">new_video = video.set_audio(audio) </span><br><span class="line"></span><br><span class="line">new_video.write_videofile(<span class="string">&#x27;new_vis_wind.mp4&#x27;</span>, bitrate=<span class="string">&#x27;5000k&#x27;</span>, audio_fps=<span class="literal">None</span>, audio_bitrate=<span class="string">&#x27;315k&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="发post请求，得到包含关键点的json数据"><a href="#发post请求，得到包含关键点的json数据" class="headerlink" title="发post请求，得到包含关键点的json数据"></a>发post请求，得到包含关键点的json数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://api-cn.faceplusplus.com/humanbodypp/v1/skeleton&#x27;</span></span><br><span class="line">api_key = <span class="string">&#x27;自己的api_key&#x27;</span></span><br><span class="line">api_secret = <span class="string">&#x27;自己的api_secret&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐张图片调用旷世的api，保存每个人的坐标信息和关键点信息的json</span></span><br><span class="line">imgpath = <span class="string">&#x27;img&#x27;</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(imgpath):</span><br><span class="line">img = os.path.join(imgpath, filename)</span><br><span class="line">files = &#123;<span class="string">&#x27;image_file&#x27;</span>: <span class="built_in">open</span>(img, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">form = &#123;<span class="string">&#x27;api_key&#x27;</span>: api_key, <span class="string">&#x27;api_secret&#x27;</span>: api_secret&#125;</span><br><span class="line">res = requests.post(url, form, files=files).json()</span><br><span class="line">json_path = os.path.join(<span class="string">&#x27;json&#x27;</span>, filename.replace(<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>))</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">json.dump(res, f)</span><br></pre></td></tr></table></figure><h4 id="描绘骨骼线"><a href="#描绘骨骼线" class="headerlink" title="描绘骨骼线"></a>描绘骨骼线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">imgdir = <span class="string">&#x27;img&#x27;</span></span><br><span class="line">jsondir = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">drawdir = <span class="string">&#x27;img_2&#x27;</span></span><br><span class="line"></span><br><span class="line">poskeys = [<span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;neck&#x27;</span>, <span class="string">&#x27;left_hand&#x27;</span>, <span class="string">&#x27;left_elbow&#x27;</span>, <span class="string">&#x27;left_shoulder&#x27;</span>, <span class="string">&#x27;right_hand&#x27;</span>, <span class="string">&#x27;right_elbow&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;right_shoulder&#x27;</span>, <span class="string">&#x27;left_buttocks&#x27;</span>, <span class="string">&#x27;left_knee&#x27;</span>, <span class="string">&#x27;left_foot&#x27;</span>, <span class="string">&#x27;right_buttocks&#x27;</span>, <span class="string">&#x27;right_knee&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;right_foot&#x27;</span>]</span><br><span class="line"><span class="comment"># 描绘14根线条</span></span><br><span class="line"><span class="comment"># 需要来确定骨架线的颜色</span></span><br><span class="line"></span><br><span class="line">colors = &#123;<span class="string">&#x27;head-neck&#x27;</span>: (<span class="number">153</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="string">&#x27;neck-left_shoulder&#x27;</span>: (<span class="number">0</span>, <span class="number">0</span>, <span class="number">153</span>), <span class="string">&#x27;neck-right_shoulder&#x27;</span>: (<span class="number">0</span>, <span class="number">51</span>, <span class="number">153</span>), </span><br><span class="line">  <span class="string">&#x27;left_shoulder-left_elbow&#x27;</span>: (<span class="number">0</span>, <span class="number">102</span>, <span class="number">153</span>), <span class="string">&#x27;left_elbow-left_hand&#x27;</span>: (<span class="number">0</span>, <span class="number">153</span>, <span class="number">153</span>), <span class="string">&#x27;right_shoulder-right_elbow&#x27;</span>: (<span class="number">0</span>, <span class="number">153</span>, <span class="number">102</span>),</span><br><span class="line">  <span class="string">&#x27;right_elbow-right_hand&#x27;</span>: (<span class="number">0</span>, <span class="number">153</span>, <span class="number">51</span>), <span class="string">&#x27;left_shoulder-left_buttocks&#x27;</span>: (<span class="number">0</span>, <span class="number">153</span>, <span class="number">0</span>), <span class="string">&#x27;left_buttocks-left_knee&#x27;</span>: (<span class="number">51</span>, <span class="number">153</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="string">&#x27;left_knee-left_foot&#x27;</span>: (<span class="number">102</span>, <span class="number">153</span>, <span class="number">0</span>), <span class="string">&#x27;right_shoulder-right_buttocks&#x27;</span>: (<span class="number">153</span>, <span class="number">153</span>, <span class="number">0</span>), <span class="string">&#x27;right_buttocks-right_knee&#x27;</span>: (<span class="number">153</span>, <span class="number">102</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="string">&#x27;right_knee-right_foot&#x27;</span>: (<span class="number">153</span>, <span class="number">51</span>, <span class="number">0</span>), <span class="string">&#x27;left_buttocks-right_buttocks&#x27;</span>: (<span class="number">61</span>, <span class="number">0</span>, <span class="number">153</span>)&#125;</span><br><span class="line">linewidth = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_skeleton</span>(<span class="params">img, poses</span>):</span></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> poses:</span><br><span class="line">body = pos[<span class="string">&#x27;body_rectangle&#x27;</span>]</span><br><span class="line">loc = [body[<span class="string">&#x27;left&#x27;</span>], body[<span class="string">&#x27;top&#x27;</span>], body[<span class="string">&#x27;width&#x27;</span>], body[<span class="string">&#x27;height&#x27;</span>]]</span><br><span class="line"><span class="comment"># 是否描绘每个人的框</span></span><br><span class="line"><span class="comment"># cv2.rectangle(img, pt1=(loc[0], loc[1]), pt2=(loc[0]+loc[2], loc[1]+loc[3]), color=colors[&#x27;head-neck&#x27;], thickness=linewidth)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到关键点的相对坐标</span></span><br><span class="line">landmarks = pos[<span class="string">&#x27;landmark&#x27;</span>]</span><br><span class="line">head = (landmarks[<span class="string">&#x27;head&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;head&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">neck = (landmarks[<span class="string">&#x27;neck&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;neck&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_hand = (landmarks[<span class="string">&#x27;left_hand&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_hand&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_elbow = (landmarks[<span class="string">&#x27;left_elbow&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_elbow&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_shoulder = (landmarks[<span class="string">&#x27;left_shoulder&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_shoulder&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_hand = (landmarks[<span class="string">&#x27;right_hand&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_hand&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_elbow = (landmarks[<span class="string">&#x27;right_elbow&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_elbow&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_shoulder = (landmarks[<span class="string">&#x27;right_shoulder&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_shoulder&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_buttocks = (landmarks[<span class="string">&#x27;left_buttocks&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_buttocks&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_knee = (landmarks[<span class="string">&#x27;left_knee&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_knee&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">left_foot = (landmarks[<span class="string">&#x27;left_foot&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;left_foot&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_buttocks = (landmarks[<span class="string">&#x27;right_buttocks&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_buttocks&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_knee = (landmarks[<span class="string">&#x27;right_knee&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_knee&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">right_foot = (landmarks[<span class="string">&#x27;right_foot&#x27;</span>][<span class="string">&#x27;x&#x27;</span>], landmarks[<span class="string">&#x27;right_foot&#x27;</span>][<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由关键点的相对坐标得到绝对坐标</span></span><br><span class="line">head = (head[<span class="number">0</span>]+loc[<span class="number">0</span>], head[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">neck = (neck[<span class="number">0</span>]+loc[<span class="number">0</span>], neck[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_hand = (left_hand[<span class="number">0</span>]+loc[<span class="number">0</span>], left_hand[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_elbow = (left_elbow[<span class="number">0</span>]+loc[<span class="number">0</span>], left_elbow[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_shoulder = (left_shoulder[<span class="number">0</span>]+loc[<span class="number">0</span>], left_shoulder[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_hand = (right_hand[<span class="number">0</span>]+loc[<span class="number">0</span>], right_hand[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_elbow = (right_elbow[<span class="number">0</span>]+loc[<span class="number">0</span>], right_elbow[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_shoulder = (right_shoulder[<span class="number">0</span>]+loc[<span class="number">0</span>], right_shoulder[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_buttocks = (left_buttocks[<span class="number">0</span>]+loc[<span class="number">0</span>], left_buttocks[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_knee = (left_knee[<span class="number">0</span>]+loc[<span class="number">0</span>], left_knee[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">left_foot = (left_foot[<span class="number">0</span>]+loc[<span class="number">0</span>], left_foot[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_buttocks = (right_buttocks[<span class="number">0</span>]+loc[<span class="number">0</span>], right_buttocks[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_knee = (right_knee[<span class="number">0</span>]+loc[<span class="number">0</span>], right_knee[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line">right_foot = (right_foot[<span class="number">0</span>]+loc[<span class="number">0</span>], right_foot[<span class="number">1</span>]+loc[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描绘骨骼线</span></span><br><span class="line">cv2.line(img, pt1=head, pt2=neck, color=colors[<span class="string">&#x27;head-neck&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=neck, pt2=left_shoulder, color=colors[<span class="string">&#x27;neck-left_shoulder&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=neck, pt2=right_shoulder, color=colors[<span class="string">&#x27;neck-right_shoulder&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_shoulder, pt2=left_elbow, color=colors[<span class="string">&#x27;left_shoulder-left_elbow&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_elbow, pt2=left_hand, color=colors[<span class="string">&#x27;left_elbow-left_hand&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=right_shoulder, pt2=right_elbow, color=colors[<span class="string">&#x27;right_shoulder-right_elbow&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=right_elbow, pt2=right_hand, color=colors[<span class="string">&#x27;right_elbow-right_hand&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_shoulder, pt2=left_buttocks, color=colors[<span class="string">&#x27;left_shoulder-left_buttocks&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_buttocks, pt2=left_knee, color=colors[<span class="string">&#x27;left_buttocks-left_knee&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_knee, pt2=left_foot, color=colors[<span class="string">&#x27;left_knee-left_foot&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=right_shoulder, pt2=right_buttocks, color=colors[<span class="string">&#x27;right_shoulder-right_buttocks&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=right_buttocks, pt2=right_knee, color=colors[<span class="string">&#x27;right_buttocks-right_knee&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=right_knee, pt2=right_foot, color=colors[<span class="string">&#x27;right_knee-right_foot&#x27;</span>], thickness=linewidth)</span><br><span class="line">cv2.line(img, pt1=left_buttocks, pt2=right_buttocks, color=colors[<span class="string">&#x27;left_buttocks-right_buttocks&#x27;</span>], thickness=linewidth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(imgdir):</span><br><span class="line">imgpath = os.path.join(imgdir, file)</span><br><span class="line"><span class="comment"># 这种写法是每张图片使用自己的骨骼线，为了避免视频中骨骼线显示不稳定，每三张图片共享一个骨骼线</span></span><br><span class="line"><span class="comment"># jsonpath = os.path.join(jsondir, file.replace(&#x27;.jpg&#x27;, &#x27;.json&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每3张图片共享骨骼线</span></span><br><span class="line">jsonidx = (<span class="built_in">int</span>(file.replace(<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;&#x27;</span>))-<span class="number">1</span>)//<span class="number">3</span>+<span class="number">1</span></span><br><span class="line">jsonpath = os.path.join(jsondir, <span class="string">&#x27;%05d.json&#x27;</span>%jsonidx)</span><br><span class="line">img =  cv2.imread(imgpath)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(jsonpath) <span class="keyword">as</span> f:</span><br><span class="line">poses = json.load(f)[<span class="string">&#x27;skeletons&#x27;</span>]</span><br><span class="line">img = draw_skeleton(img, poses)</span><br><span class="line"></span><br><span class="line"><span class="comment"># img_2保存每张图一个骨骼线，img_3共享骨骼线</span></span><br><span class="line">newimgpath = os.path.join(<span class="string">&#x27;img_3&#x27;</span>, file)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(newimgpath, img)</span><br></pre></td></tr></table></figure><h4 id="将图片和mp3重组为视频"><a href="#将图片和mp3重组为视频" class="headerlink" title="将图片和mp3重组为视频"></a>将图片和mp3重组为视频</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> moviepy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">imgdir = <span class="string">&#x27;img_2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记了骨骼线的图像</span></span><br><span class="line">imgpaths = [os.path.join(imgdir, file) <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(imgdir)] <span class="comment"># 需要确保按照时间先后顺序排列</span></span><br><span class="line"></span><br><span class="line">video = moviepy.video.io.ImageSequenceClip.ImageSequenceClip(imgpaths, fps=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">audio = AudioFileClip(<span class="string">&#x27;video_wind.mp3&#x27;</span>, fps=<span class="number">48000</span>)</span><br><span class="line"></span><br><span class="line">new_video = video.set_audio(audio) <span class="comment"># 必须要使用新的变量来承接改变后的视频</span></span><br><span class="line"></span><br><span class="line">new_video.write_videofile(<span class="string">&#x27;new_video_wind_1.mp4&#x27;</span>, bitrate=<span class="string">&#x27;2590k&#x27;</span>, audio_fps=<span class="literal">None</span>, audio_bitrate=<span class="string">&#x27;315k&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h4><div style="text-align: center"><img src="/assets/blog/87cfe86f/keypoints.jpg" margin="0 auto" width="100%" height="100%"/></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;从视频中提取图片（cv2）–&amp;gt;调用face++的api返回json数据（posts）–&amp;gt;骨骼线描绘–&amp;gt;图片和mp3重组为mp4（moviepy）&lt;/p&gt;</summary>
    
    
    
    
    <category term="姿态估计" scheme="http://xkwang.cn/tags/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>C++中array new的底层实现</title>
    <link href="http://xkwang.cn/post/3cec0647.html"/>
    <id>http://xkwang.cn/post/3cec0647.html</id>
    <published>2021-04-22T00:53:25.000Z</published>
    <updated>2021-04-22T00:59:08.225Z</updated>
    
    <content type="html"><![CDATA[<p>cpp array new的底层实现相比较于new只是多了几次构造函数的调用，同时array delete相比较于delete只是多了几次析构函数的调用，对于内存的分配和释放，array版本和非array版本都只进行了一次。</p><a id="more"></a><h4 id="array-new的底层实现"><a href="#array-new的底层实现" class="headerlink" title="array new的底层实现"></a>array new的底层实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> Complex[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> [] pc;</span><br><span class="line"><span class="comment">// 上述代码的底层实现如下</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex)*<span class="number">3</span>);</span><br><span class="line">Complex* pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line">Complex* temp = pc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">new</span>(temp++)Complex(); <span class="comment">// 调用默认的构造函数3次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp = pc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    temp = pc+i;</span><br><span class="line">    temp-&gt;~Complex(); <span class="comment">// 相反的顺序调用三次析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(pc);</span><br><span class="line"><span class="comment">// “3”的数值是保存在malloc构造时的cookie中</span></span><br></pre></td></tr></table></figure><p>new array的底层实现仅仅是多调用了几次构造和析构函数。</p><p>编程时要求array new和array delete必须配套使用，否则可能产生内存泄漏。也就是上述代码中必须要使用delete [] pc，不能漏掉[]。</p><p>不过上述代码即使漏掉了[]也不存在内存泄露问题，漏掉了就会只调用一次析构函数，但是Complex对象中不存在指针对象，没有指向其它的空间，仅仅只是实部和虚部的整形变量，因此，其析构函数是无意义的。</p><p>下面的代码如果没有使用array delete会造成内存泄漏，因为对于string对象其成员是指针，实际的字符串存放在另外的空间，因此，string的析构函数是有意义的，漏掉了[]会导致两个string的内存空间无法释放，造成内尺寸泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">// 内存泄漏</span></span><br></pre></td></tr></table></figure><p>上述两种情形的内存布局如下图：</p><div style="text-align: center"><img src="/assets/blog/3cec0647/mem.png" margin="0 auto" width="100%" height="50%"/></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp array new的底层实现相比较于new只是多了几次构造函数的调用，同时array delete相比较于delete只是多了几次析构函数的调用，对于内存的分配和释放，array版本和非array版本都只进行了一次。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ operator new重载</title>
    <link href="http://xkwang.cn/post/97281ac2.html"/>
    <id>http://xkwang.cn/post/97281ac2.html</id>
    <published>2021-04-22T00:51:30.000Z</published>
    <updated>2021-04-22T01:00:25.202Z</updated>
    
    <content type="html"><![CDATA[<p>cpp中operator new或者placement new是内存管理的中间层，直接关系到allocator和new的具体实现，因此，实现operator new或者placement new的重载是实现内存接管的方法。</p><a id="more"></a><p>对于operator new的重载，包含全局重载和在类中进行重载，其中全局重载的影响是全局的，一般不推荐，主要使用第二种类内重载。</p><h4 id="全局重载"><a href="#全局重载" class="headerlink" title="全局重载"></a>全局重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">myAlloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">myFree</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global new() \n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> myAlloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global new[]()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> myAlloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global delete() \n&quot;</span>;</span><br><span class="line">    myFree(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;global delete[]()\n&quot;</span>;</span><br><span class="line">    myFree(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类内重载"><a href="#类内重载" class="headerlink" title="类内重载"></a>类内重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>; <span class="comment">// size_t可选</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">size_t</span>); <span class="comment">// size_t可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按道理上述的重载函数需要是static，因为operator new的对象还没创建完成，没办法通过对象来进行函数调用，因此需要是static来实现通过类调用函数。不过cpp考虑到了这个问题，没有把上述写法当作一种错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要调用自己的内存管理工具</span></span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用下面的方式，会强制调用全局版本，上述的重载失效</span></span><br><span class="line">Foo* pf = ::<span class="keyword">new</span> Foo;</span><br><span class="line">::<span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure><h4 id="placement-new的各种重载"><a href="#placement-new的各种重载" class="headerlink" title="placement new的各种重载"></a>placement new的各种重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Foo::Foo()&quot;</span>;&#125;</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Foo::Foo(int)&quot;</span>&lt;&lt;<span class="built_in">endl</span>; <span class="keyword">throw</span> Bad();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本第一个元素类型必须要是size_t</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 一般的operator new重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// placement new的重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span>* start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的placement new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size+extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的placement new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">long</span> extra, <span class="keyword">char</span> init)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size+extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的placement delete版本，逐条对应上述的placement new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>&#123; <span class="comment">// size_t可缺省</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;operator delete(void*, size_t)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;operator delete(void*, void*)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">long</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;operator delete(void*, long)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">long</span>, <span class="keyword">char</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;operator delete(void*, long, char)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述的placement delete一般不会被调用，只有当我们的placement new出现异常时才会调用我们自己的placement delete，这实际上类似一种异常处理的handler。因此，也不需要全部 写好对应的placement delete，没写的代表放弃了异常处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp中operator new或者placement new是内存管理的中间层，直接关系到allocator和new的具体实现，因此，实现operator new或者placement new的重载是实现内存接管的方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理初步</title>
    <link href="http://xkwang.cn/post/af3f7fe3.html"/>
    <id>http://xkwang.cn/post/af3f7fe3.html</id>
    <published>2021-04-22T00:46:02.000Z</published>
    <updated>2021-04-22T01:01:53.326Z</updated>
    
    <content type="html"><![CDATA[<p>cpp提供了不同层次的内存管理工具，如malloc、new和allocator，所有的管理工具最终都是调用malloc，同时malloc最底层是调用系统的内存管理工具API。</p><a id="more"></a><p>关键点：cpp中提供给程序员的内存管理工具有malloc、new和allocator。</p><blockquote><p>allocator是给容器使用，只定义了实现接口的标准，具体实现方式没有要求，现在很多编译器allocator的实现仅仅是对new和delete做了一层简单的封装，效率低，之前版本的gnuc中使用了内存池+malloc的方式实现了高效的内存管理。</p><p>new实现内存管理调用了operator new进行内存分配+placement new实现对象构造。operator new可以由用户进行重载，由此实现内存管理的接管，cpp中全局的operator new底层是malloc实现。</p></blockquote><p>内存管理的两个关键点：1.了解内存管理是如何调用到底层的malloc的；2.实现operator new的重载和allocator的自定义来实现内存管理接管。</p><h4 id="概念了解"><a href="#概念了解" class="headerlink" title="概念了解"></a>概念了解</h4><p>cpp内存管理malloc、new、operator new、allocator。</p><p>malloc不可被重载，new是cpp的关键字，由cpp标准确定下来了也不能重载，operator new可以被重载，也是接管内存管理的方式，allocator可以自定义然后将自定义版本传递给容器，也能实现内存管理的接管。</p><p>一般不直接使用allocator来进行内存分配，因为使用起来比较麻烦，并且需要程序员自己记住分配的内存大小。</p><h4 id="malloc、new、allocator分配内存实例"><a href="#malloc、new、allocator分配内存实例" class="headerlink" title="malloc、new、allocator分配内存实例"></a>malloc、new、allocator分配内存实例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p1 =<span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;* p2= <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">512</span>);</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用cpp提供的标准库中的allocator进行内存管理</span></span><br><span class="line"><span class="comment">// 标准库定义了接口，但是不同的厂商并未完全遵守。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">  <span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line">  allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BORLANDC_</span></span><br><span class="line">  <span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">5</span>);</span><br><span class="line">  allocator&lt;<span class="keyword">int</span>&gt;().deallocate(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line">  <span class="comment">// 这两个函数都是static，可通过全名调用之</span></span><br><span class="line">  <span class="keyword">void</span>* p4 = alloc::allocate(<span class="number">512</span>);</span><br><span class="line">  alloc::deallocate(p4, <span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下两函数都是non-static，需要通过object调用</span></span><br><span class="line">  <span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">7</span>);</span><br><span class="line">  allocator&lt;<span class="keyword">int</span>&gt;.deallocate((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用内存池实现</span></span><br><span class="line">  <span class="keyword">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().allocate(<span class="number">9</span>);</span><br><span class="line">  __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt;().deallocate((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="new-expression的底层实现"><a href="#new-expression的底层实现" class="headerlink" title="new expression的底层实现"></a>new expression的底层实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 底层实现如下方代码</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex)); <span class="comment">// 调用operator new分配内存，operator new的底层是的调用malloc</span></span><br><span class="line"><span class="comment">//如果重载了operator new便自己接管了内存管理任务</span></span><br><span class="line">Complex* pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">// 进行类型转换</span></span><br><span class="line"><span class="keyword">new</span>(pc)Complex(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 使用placement new执行构造函数，不能使用指针直接调用构造函数（个人理解如果直接能够用的话，与构造函数的语义相违背）</span></span><br></pre></td></tr></table></figure><p>operator new可以被重载，便能实现内存管理的接管，至于operator new的底层如何实现，标准库没有要求，但是目前普遍使用malloc来实现内存管理。同时operator new考虑分配失败时调用用户定义的handler函数，确保malloc能分配到内存或者实现分配不到内存返回0让malloc退出。仅仅只是对malloc做了一点简单的封装。</p><p>对于上述的placement new实现，底层实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(pc)Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//内部实现如下，以下忽略了异常捕获</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex), buf); <span class="comment">// operator new的一种重载形式</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);</span><br><span class="line"><span class="comment">// 第三行</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一行是operator new的重载版本，内部实现如下：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* loc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对配套使用的delete pc进行解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line"><span class="comment">// 底层实现如下代码</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~Complex(); <span class="comment">// 可以直接调用构造函数，因为pc现在指向了Complex对象</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> pc; <span class="comment">// 底层实现是直接free(pc);</span></span><br></pre></td></tr></table></figure><p><strong>tips:</strong> 析构函数的意义主要是对程序员分配的堆空间（调用new或者malloc）进行回收，以及调用成员的析构函数来实现成员变量的堆空间的释放。换言之，如果对象自身没有分配堆空间，成员变量也没有分配堆空间，那么析构函数是没有用的。当然除了物理资源的管理，析构函数也常常用来实现其它资源管理，如互斥锁的释放，以及计数器的减小（如智能指针的实现）。</p><p>vector分配器底层还是调用malloc，其数据保存还是放在堆区，同手动malloc分配方式。</p><h4 id="allocator的底层实现"><a href="#allocator的底层实现" class="headerlink" title="allocator的底层实现"></a>allocator的底层实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T* p = allocate();</span><br><span class="line">construct();</span><br><span class="line">...</span><br><span class="line">destroy();</span><br><span class="line">deallocate p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述是一般的接口形式，不同厂商的实现方式略有不同</span></span><br><span class="line"><span class="comment">// G4.9 new_allocator 或者现在的std::allocator</span></span><br><span class="line">allocate();</span><br><span class="line">deallocate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用目前最新版里面的的内存池的allocator __pool_alloc</span></span><br><span class="line">allocate();</span><br><span class="line">deallocate();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述代码底层调用</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而上述代码最终调用malloc和free</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="keyword">size_t</span>);</span><br><span class="line"><span class="built_in">free</span>(<span class="keyword">void</span>*);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以发现，无论是new expression还是allocator.allocate()，底层都是调用::operator new，底层再去调用malloc，同理相反的delete和deallocate()底层都是调用::operator delete，底层再去调用free。因此如果实现了对operator new的重载，便接管了内存管理！而对于内存释放operator delete一般不去重载。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp提供了不同层次的内存管理工具，如malloc、new和allocator，所有的管理工具最终都是调用malloc，同时malloc最底层是调用系统的内存管理工具API。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://xkwang.cn/post/fb62aca2.html"/>
    <id>http://xkwang.cn/post/fb62aca2.html</id>
    <published>2021-04-20T05:57:31.000Z</published>
    <updated>2021-04-20T05:59:17.639Z</updated>
    
    <content type="html"><![CDATA[<p>牛顿迭代法用于近似求解多项式的零点十分方便，收敛速度也很快，比二分法还快。</p><a id="more"></a><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>牛顿迭代法常用来求解方程的近似根，因为多数的方程没有求根公式，这也是大多数计算机内部的求解根的方法，收敛速度非常快。</p><h4 id="牛顿迭代法的思路"><a href="#牛顿迭代法的思路" class="headerlink" title="牛顿迭代法的思路"></a>牛顿迭代法的思路</h4><p>对于一般的曲线y=f(x)，通常没有求根公式，无法得到解析解，利用牛顿迭代法需要先对根的位置进行近似估计为x0，然后在x0的领域内将y=f(x)按照泰勒级数展开，并保留前几项，近似为多项式函数y=f1(x)。假设第一步的近似解是x1，那么过曲线f1(x)上点(x1, f1(x1))的切线为y=f1(x1)+f1’(x1)(x-x1)，那么该切线与x轴交点是x=x1-f1(x1)/f1’(x1)，记作x1=x1-f1(x1)/f1’(x1)，同理进行类推，得到了递推公式x(n+1)=x(n)-f1(x(n))/f1’(x(n))，不断迭代下去便能不断逼近真正的零点。</p><p>由于进行泰勒展开需要先预先估计零点，有误差，并且泰勒展开本身也有误差，并且最后的根也是近似的，因此实际中感觉还是多项式函数的根比较好用牛顿迭代法，对于多项式函数就不需要进行泰勒展开了。</p><p>例题：给定一个非负整数，求它的开方，向下取整。</p><p>构造函数y=x^2-a，那么迭代公式x(n+1)=[x(n)+a/x(n)]/2，直接把a当作初值迭代即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(in a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x=a;</span><br><span class="line">    <span class="comment">// 需要确保x*x不越界，因此需要把x定义为long int</span></span><br><span class="line">    <span class="keyword">while</span>(x*x&gt;a)&#123;</span><br><span class="line">        x=(x+a/x)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;牛顿迭代法用于近似求解多项式的零点十分方便，收敛速度也很快，比二分法还快。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://xkwang.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++模板编程</title>
    <link href="http://xkwang.cn/post/ade28559.html"/>
    <id>http://xkwang.cn/post/ade28559.html</id>
    <published>2021-04-13T10:47:27.000Z</published>
    <updated>2021-04-13T10:50:49.386Z</updated>
    
    <content type="html"><![CDATA[<p>模板编程主要涉及函数模板、类模板、成员函数模板以及泛化、全特化、偏特化的概念。</p><a id="more"></a><h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><p>模板本身概念比较简单，主要包含函数模板、类模板、类成员函数模板</p><p>比较麻烦的是友元函数模板和关于类模板的继承</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板可以进行自动类型推导，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mymax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymax(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymax(<span class="number">1.0</span>, <span class="number">2.0</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 注意1.0被自动推断类型是double而不是float</span></span><br><span class="line">    <span class="comment">// 如果需要使用float需要自己明确指出类型为float 1.0f 形式</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymax&lt;<span class="keyword">float</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 错误，函数模板可以进行类型推导，</span></span><br><span class="line">    <span class="comment">// 但是必须精确匹配，如果需要进行自动类型转换则必须指定具体类型</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymax(<span class="number">1.0</span>, <span class="number">2</span>) &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载调用优先级 精确匹配的函数模板 &gt; 可以精确匹配的函数模板 &gt; 指定类型需要进行自动类型转换的函数模板 &gt; 需要进行自动类型转换的普通函数。</p><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板就是把类成员变量的类型用模板定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(T num, T price): num(num), price(price) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T num;</span><br><span class="line">    T price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Book&lt;<span class="keyword">int</span>&gt; <span class="title">book</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类成员函数模板"><a href="#类成员函数模板" class="headerlink" title="类成员函数模板"></a>类成员函数模板</h4><p>类成员模板就是把函数模板作为类的成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(T num, T price): num(num), price(price) &#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T1 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T num;</span><br><span class="line">    T price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Book&lt;<span class="keyword">int</span>&gt; <span class="title">book</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; book &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    book.showInfo(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    book.showInfo&lt;<span class="keyword">float</span>&gt;(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h4><p>上述的举例子都是泛化的例子</p><h4 id="特化（全特化）"><a href="#特化（全特化）" class="headerlink" title="特化（全特化）"></a>特化（全特化）</h4><p>（全）特化则是模板的类型进行了具体化</p><p>类模板全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(T num, T price): num(num), price(price) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;class T&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T1 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T num;</span><br><span class="line">    T price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&lt;</span><span class="keyword">float</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">float</span> num, <span class="keyword">float</span> price): num(num), price(price) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T1 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> num;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Book&lt;<span class="keyword">int</span>&gt; <span class="title">book1</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 调用泛化版本</span></span><br><span class="line">    <span class="function">Book&lt;<span class="keyword">float</span>&gt; <span class="title">book2</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>; <span class="comment">// 调用特化模板</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板全特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T t1, T t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;class T&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> t1, <span class="keyword">float</span> t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(<span class="number">1.0f</span>, <span class="number">2.0f</span>); <span class="comment">// 调用泛化版本</span></span><br><span class="line">    fun(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// 调用全特化版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>类模板偏特化，重载时挑选最匹配的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(T1 num, T2 price): num(num), price(price) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;class T1, class T2&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T3 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 num;</span><br><span class="line">    T2 price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&lt;</span><span class="keyword">int</span>, T2&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">int</span> num, T2 price): num(num), price(price) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;class T2&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T3 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    T2 price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">float</span>&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">int</span> num, <span class="keyword">float</span> price): num(num), price(price) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, Book&amp; book)&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;Book num: &quot;</span> &lt;&lt; book.num &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; book.price;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(T1 t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The book info value: &quot;</span> &lt;&lt; t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Book&lt;int, float&gt; book1(10, 100); // 调用全特化</span><br><span class="line">    Book&lt;int, int&gt; book2(10, 100); // 调用偏特化</span><br><span class="line">    Book&lt;float, int&gt; book3(10.0, 100); // 调用泛化版</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++标准中，模板函数不能偏特化，但是可以重载。但是发现我写了类似偏特化的版本没有报错，但是不会去调用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;class T&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> t1, <span class="keyword">float</span> t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> t1, T t2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;template &lt;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(<span class="number">1.0f</span>, <span class="number">2.0f</span>); <span class="comment">// 调用泛化版本</span></span><br><span class="line">    fun(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">// 调用全特化版本</span></span><br><span class="line">    fun(<span class="number">1</span>, <span class="number">2.0f</span>); <span class="comment">// 调用泛化版本</span></span><br><span class="line">    fun&lt;<span class="keyword">int</span>, <span class="keyword">float</span>&gt;(<span class="number">1</span>, <span class="number">2.0f</span>); <span class="comment">// 进行类型转换，调用全特化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;模板编程主要涉及函数模板、类模板、成员函数模板以及泛化、全特化、偏特化的概念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载</title>
    <link href="http://xkwang.cn/post/1dfa3723.html"/>
    <id>http://xkwang.cn/post/1dfa3723.html</id>
    <published>2021-04-13T10:43:23.000Z</published>
    <updated>2021-04-13T10:51:47.778Z</updated>
    
    <content type="html"><![CDATA[<p>C++运算符重载，主要需要注意流运算符一般是通过友元函数来实现重载，这是因为如果通过成员函数重载，那么对象是在&lt;&lt;或&gt;&gt;的左边，不仅很奇怪，而且无法实现连续调用形式。</p><a id="more"></a><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>不能重载的运算符</p><p><strong>.  .*   ::  ?:  sizeof</strong></p><p>只能作为类成员函数重载</p><p><strong>() [] -&gt; =</strong></p><p>构造一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Book();</span><br><span class="line">        ~Book();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> price;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下标的重载"><a href="#下标的重载" class="headerlink" title="下标的重载"></a>下标的重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book() : price(<span class="number">0</span>), num(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(author, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*maxSize);</span><br><span class="line">    &#125;;</span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    Book&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    ~Book() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能使用成员函数实现</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> [](<span class="keyword">size_t</span> i) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> author[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Book::<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=maxSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Index out of range!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> author[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流运算符重载"><a href="#流运算符重载" class="headerlink" title="流运算符重载"></a>流运算符重载</h4><ol><li>流运算符只能重载为普通函数，不能重载为成员函数，重载为成员函数需要&lt;&lt;或者&gt;&gt;左侧的对象是我们定义的对象，这样就造成了Object&lt;&lt;cin或者Object&gt;&gt;cout的使用，与常规调用方法不符合，因此一般只重载为普通函数。</li><li>重载为一般函数时如果要访问private成员则需要定义为类的友元。</li></ol><p>上述的Book类进行流运算符重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book() : price(<span class="number">0</span>), num(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    ~Book() &#123;&#125;;</span><br><span class="line">    <span class="comment">// 友元函数声明时需要添加friend关键词</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; is, Book&amp; book);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行友元函数的定义时不需要添加friend，否则会报错</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Book&amp; book)&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;Book price: &quot;</span>&lt;&lt;book.price&lt;&lt;<span class="string">&quot; num: &quot;</span>&lt;&lt;book.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; is, Book&amp; book)&#123;</span><br><span class="line">    is&gt;&gt;book.price&gt;&gt;book.num;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单目运算符重载"><a href="#单目运算符重载" class="headerlink" title="单目运算符重载"></a>单目运算符重载</h4><p>自增运算符/自减运算符 分别重载为类成员函数 和 普通函数</p><p>两种形式都能定义，但是类成员和普通成员函数只能定义一种，否则调用时含义不明</p><p>同时能发现对于后置运算符，需要定义拷贝构造函数和拷贝赋值运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book() : price(<span class="number">0</span>), num(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    Book&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    ~Book() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Book&amp; operator ++ (); // 前置 允许++++a</span></span><br><span class="line"><span class="comment">//    const Book operator ++ (int n); // 后置 不允许a++++</span></span><br><span class="line"><span class="comment">//    Book&amp; operator --(); // 前置 允许----a</span></span><br><span class="line"><span class="comment">//    const Book operator --(int n); // 后置 不允许a----</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Book&amp; <span class="keyword">operator</span> ++(Book&amp; book);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Book <span class="keyword">operator</span> ++(Book&amp; book, <span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Book&amp; <span class="keyword">operator</span> --(Book&amp; book);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Book <span class="keyword">operator</span> --(Book&amp; book, <span class="keyword">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; is, Book&amp; book);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝运算的定义</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; book)&#123;</span><br><span class="line">    price = book.price;</span><br><span class="line">    num = book.num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book&amp; Book::<span class="keyword">operator</span> = (<span class="keyword">const</span> Book&amp; rhs)&#123;</span><br><span class="line">    <span class="comment">// 按道理不能运行</span></span><br><span class="line">    price = rhs.price;</span><br><span class="line">    num = rhs.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Book&amp; Book::operator ++()&#123;</span></span><br><span class="line"><span class="comment">//    ++price;</span></span><br><span class="line"><span class="comment">//    ++num;</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//// 从这里看出是需要定义拷贝复制运算符的</span></span><br><span class="line"><span class="comment">//const Book Book::operator ++(int n)&#123;</span></span><br><span class="line"><span class="comment">//    Book old = *this;</span></span><br><span class="line"><span class="comment">//    ++price;</span></span><br><span class="line"><span class="comment">//    ++num;</span></span><br><span class="line"><span class="comment">//    return old;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Book&amp; Book::operator --()&#123;</span></span><br><span class="line"><span class="comment">//    --price;</span></span><br><span class="line"><span class="comment">//    --num;</span></span><br><span class="line"><span class="comment">//    return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//const Book Book::operator--(int n)&#123;</span></span><br><span class="line"><span class="comment">//    Book old=*this;</span></span><br><span class="line"><span class="comment">//    --price;</span></span><br><span class="line"><span class="comment">//    --num;</span></span><br><span class="line"><span class="comment">//    return old;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的实现 友元函数就没有域作用符号了，不是类成员</span></span><br><span class="line">Book&amp; <span class="keyword">operator</span> ++(Book&amp; book) &#123;</span><br><span class="line">    ++book.price;</span><br><span class="line">    ++book.num;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Book <span class="keyword">operator</span> ++(Book&amp; book, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    Book old = book;</span><br><span class="line">    ++book.price;</span><br><span class="line">    ++book.num;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book&amp; <span class="keyword">operator</span> --(Book&amp; book) &#123;</span><br><span class="line">    --book.price;</span><br><span class="line">    --book.num;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Book <span class="keyword">operator</span> --(Book&amp; book, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    Book old = book;</span><br><span class="line">    --book.price;</span><br><span class="line">    --book.num;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行普通函数的自增、自减的重载 需要定义为友元</span></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Book&amp; book)&#123;</span><br><span class="line">    os&lt;&lt;<span class="string">&quot;Book price: &quot;</span>&lt;&lt;book.price&lt;&lt;<span class="string">&quot; num: &quot;</span>&lt;&lt;book.num;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; is, Book&amp; book)&#123;</span><br><span class="line">    is&gt;&gt;book.price&gt;&gt;book.num;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双目运算符重载"><a href="#双目运算符重载" class="headerlink" title="双目运算符重载"></a>双目运算符重载</h4><p>同时实现成员函数和友元函数，会优先调用成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book() : price(<span class="number">0</span>), num(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(author, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*maxSize);</span><br><span class="line">    &#125;;</span><br><span class="line">    Book(<span class="keyword">int</span> price, <span class="keyword">int</span> num): price(price), num(num) &#123;&#125;;</span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; book);</span><br><span class="line">    Book&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Book&amp; rhs);</span><br><span class="line">    <span class="comment">// 一般加号返回右值 会优先调用成员函数</span></span><br><span class="line">    <span class="keyword">const</span> Book <span class="keyword">operator</span> + (<span class="keyword">const</span> Book&amp; rhs);</span><br><span class="line">    <span class="comment">// 使用友元函数实现</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Book <span class="keyword">operator</span> + (<span class="keyword">const</span> Book&amp; lhs, <span class="keyword">const</span> Book&amp; rhs);</span><br><span class="line">    ~Book() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os ,<span class="keyword">const</span> Book&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> author[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝运算的定义</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; book)&#123;</span><br><span class="line">    price = book.price;</span><br><span class="line">    num = book.num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Book&amp; Book::<span class="keyword">operator</span> = (<span class="keyword">const</span> Book&amp; rhs)&#123;</span><br><span class="line">    <span class="comment">// 按道理不能运行</span></span><br><span class="line">    price = rhs.price;</span><br><span class="line">    num = rhs.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Book Book::<span class="keyword">operator</span>+(<span class="keyword">const</span> Book &amp;rhs) &#123;</span><br><span class="line">    <span class="function">Book <span class="title">book</span><span class="params">(price+rhs.price, num+rhs.num)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;member function &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Book <span class="keyword">operator</span> + (<span class="keyword">const</span> Book&amp; lhs, <span class="keyword">const</span> Book&amp; rhs) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;friend function &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> Book(lhs.price+rhs.price, lhs.num+rhs.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> Book&amp; rhs)&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Book price: &quot;</span> &lt;&lt; rhs.price &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot; num: &quot;</span> &lt;&lt; rhs.num;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++运算符重载，主要需要注意流运算符一般是通过友元函数来实现重载，这是因为如果通过成员函数重载，那么对象是在&amp;lt;&amp;lt;或&amp;gt;&amp;gt;的左边，不仅很奇怪，而且无法实现连续调用形式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的优先队列</title>
    <link href="http://xkwang.cn/post/d48ef435.html"/>
    <id>http://xkwang.cn/post/d48ef435.html</id>
    <published>2021-04-06T16:02:49.000Z</published>
    <updated>2021-04-06T16:06:07.400Z</updated>
    
    <content type="html"><![CDATA[<p>C++优先队列默认的是大根堆。</p><a id="more"></a><p>优先队列的特点：</p><blockquote><p>首先优先队列延续了队列的内涵，从队尾入队，从队头出队。但是入队出队过程并不是传统的FIFO方式，而是在内部给成员确定了优先级，每个元素出队时按照优先级最大或者最小进行出队。优先队列的这种数据结构就是最大堆或者最小堆。因此，如果需要使用最大堆或者最小堆的问题，可以直接使用优先队列来解决。</p><p>元素入队时先排在堆的最后一个位置，然后进行上浮；元素出队时取出根节点元素，将最后一个节点放入根节点，然后进行下浮。对于优先队列这种由STL实现的数据结构来说，我们已经不需要自己去实现这种模板的功能，只需要将模板具体化就能方便使用。</p></blockquote><p>优先队列的使用：</p><p>1.#include<queue>包含队列的头文件 注意有个万能头文件，实现需要去判断下oj平台是否支持，#include &lt;bits/stdc++.h&gt;</p><p>2.优先队列的构造<br>   <code>template&lt;_Tp, _Sequence = vector&lt;_Tp&gt;, _Compare = less&lt;value_type&gt;&gt;</code><br>   优先队列使用就是模板实例化，具体来说需要指定三个参数，_Tp, _Sequence和_Sequence三部分。其中第一个是容器内部具体要保存的数据类型，比如int，float，pair或者tuple，_Sequence代表底层容器的具体类型，如vector、deque等，cpp默认的容器是vecctor，而_Compare函数则是用户定义的比较函数，决定了比较的元素和比较的规则，cpp默认是按照_Tp中的第一个元素进行比较，并且默认是大根堆。<br>   例如</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;tuple&lt;<span class="keyword">float</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;q; <span class="comment">//默认使用第一个元素比较，产生大根堆</span></span><br></pre></td></tr></table></figure><p>   等价于<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> eletype = tuple&lt;<span class="keyword">float</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">// 注意这里小于号对应大根堆，大于号对应小根堆</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](eletype a, eletype b) &#123;<span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(a) &lt; get&lt;<span class="number">0</span>&gt;(b);&#125;; </span><br><span class="line"><span class="built_in">priority_queue</span>&lt;eletype, <span class="built_in">vector</span>&lt;eletype&gt;, <span class="keyword">decltype</span>(cmp)&gt;q(cmp);</span><br></pre></td></tr></table></figure><br>   注意几点：</p><ul><li>cpp中定义lambda表达式是看不到lambda字眼的，不要和python搞混了；</li><li>cpp定义lambda表达式结尾的大括号处需要添加分号；</li><li>cpp中tuple不能直接使用下标访问，需要使用get<idx>(tuple)的方式来访问；</li><li>cpp中优先队列需要在模板的第三个参数给出比较函数类型，同时需要在构造优先队列对象时给构造函数传入具体的比较函数。<br>对于tuple的具体解包，可以使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;element&#123;<span class="number">1.12</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//用法和vector初始化很类似</span></span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = element;</span><br></pre></td></tr></table></figure></li></ul><p>3.优先队列的操作</p><ul><li>出队：pop函数，返回类型void;</li><li>入队：push函数，需要先构建一个临时变量，再调用复制构造函数到队列的尾部；emplace函数，直接原地构造，传入对象构造函数所需参数；</li><li>访问队头元素：top函数；</li><li>队列元素数量：size函数</li><li>队列是否为空：empty函数</li><li>交换内容：swap函数， queue1.swap(queue2)，将具有相同数据类型和大小的队列元素交换。</li></ul><p>cpp pair类型访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">float</span>, <span class="keyword">int</span>&gt;a&#123;<span class="number">1.0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">a.first;</span><br><span class="line">a.second;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++优先队列默认的是大根堆。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++与文件函数</title>
    <link href="http://xkwang.cn/post/db37a64d.html"/>
    <id>http://xkwang.cn/post/db37a64d.html</id>
    <published>2021-04-06T15:37:04.000Z</published>
    <updated>2021-04-06T15:38:41.770Z</updated>
    
    <content type="html"><![CDATA[<p>fseek, ftell, ferror, rewind这三个函数的具体作用，在cpp primer中没有看到，还需要去阅读深度探索cpp对象模型来进行理解。暂时留坑。</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;fseek, ftell, ferror, rewind这三个函数的具体作用，在cpp primer中没有看到，还需要去阅读深度探索cpp对象模型来进行理解。暂时留坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++mem系列函数</title>
    <link href="http://xkwang.cn/post/8841f983.html"/>
    <id>http://xkwang.cn/post/8841f983.html</id>
    <published>2021-04-06T15:32:14.000Z</published>
    <updated>2021-04-06T15:35:44.425Z</updated>
    
    <content type="html"><![CDATA[<p>memcpy  memmove memset直接对内存进行操作而不需要考虑内存存放的数据类型。</p><a id="more"></a><p>本片博客内容参考<a href="https://blog.csdn.net/zhuohaiyy/article/details/79118114">https://blog.csdn.net/zhuohaiyy/article/details/79118114</a> 版权归原作者所有。</p><p>在C语言中存在strcopy, strcmp, strcat这些函数分别实现字符串的拷贝，比较和拼接。</p><p>strcopy原型，实现从后者到前者的字符串复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span></span>;</span><br></pre></td></tr></table></figure><p>strcmp原型，实现字符串1与字符串2的比较，返回字符串1&gt;字符串2的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1,<span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span>;</span><br></pre></td></tr></table></figure><p>strcat原型，将后者的字符串拼接到前者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure><p>但是这些只能实现字符串的相关操作，如果要实现任意一种数据类型的操作则无能为力，因此C语言提供了对内存进行操作的三个函数。</p><ol><li>memcpy原型，以字节为单位，实现从后者到前者的拷贝，并且拷贝顺序是从前往后，但是memcopy函数没有考虑内存重叠问题，因此拷贝内存存在一定风险。详细参考开头提供的博客。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span> <span class="params">( <span class="keyword">void</span> * destination, <span class="keyword">const</span> <span class="keyword">void</span> * source, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></li><li>memmove原型，函数原型同memcpy一样，但是内部考虑内存重叠的方式，如果从前往后拷贝存在重叠问题，那么memmove会采用从后往前的拷贝方式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memmove</span> <span class="params">( <span class="keyword">void</span> * destination, <span class="keyword">const</span> <span class="keyword">void</span> * source, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></li><li>memset原型，从ptr开始对连续num个字节的内存赋值value。常常用于C语言中构建全零数组。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memset</span> <span class="params">( <span class="keyword">void</span> * ptr, <span class="keyword">int</span> value, <span class="keyword">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;memcpy  memmove memset直接对内存进行操作而不需要考虑内存存放的数据类型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看内核版本和发行版版本</title>
    <link href="http://xkwang.cn/post/f5394aaf.html"/>
    <id>http://xkwang.cn/post/f5394aaf.html</id>
    <published>2021-03-20T02:49:34.000Z</published>
    <updated>2021-04-06T15:25:45.460Z</updated>
    
    <content type="html"><![CDATA[<p>查看内核版本uname -a; 查看发新版版本cat /etc/os-release。</p><a id="more"></a><p>查看linux内核版本</p><ol><li>uname -a 可以看出系统是2017年10月20日安装的 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Linux</span> master <span class="number">3</span>.<span class="number">10</span>.<span class="number">0</span>-<span class="number">693</span>.<span class="number">5</span>.<span class="number">2</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span> #<span class="number">1</span> SMP Fri Oct <span class="number">20</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">50</span> UTC <span class="number">2017</span> </span><br><span class="line"><span class="attribute">x86_64</span> x<span class="number">86</span>_<span class="number">64</span> x<span class="number">86</span>_<span class="number">64</span> GNU/Linux</span><br></pre></td></tr></table></figure></li><li>cat /proc/version 这个命令还会给出编译工具信息 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Linux</span> version <span class="number">3</span>.<span class="number">10</span>.<span class="number">0</span>-<span class="number">693</span>.<span class="number">5</span>.<span class="number">2</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span> (builder@kbuilder.dev.centos.org) (gcc </span><br><span class="line"><span class="attribute">version</span> <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span> <span class="number">20150623</span> (Red Hat <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">16</span>) (GCC) ) #<span class="number">1</span> SMP Fri Oct <span class="number">20</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">50</span> UTC <span class="number">2017</span></span><br></pre></td></tr></table></figure>查看linux发行版信息 CentOS和Ubuntu通用</li></ol><p>cat /etc/os-release</p><ol><li>CentOS结果<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NAME</span>=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line"><span class="attr">VERSION</span>=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line"><span class="attr">ID</span>=<span class="string">&quot;centos&quot;</span></span><br><span class="line"><span class="attr">ID_LIKE</span>=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line"><span class="attr">VERSION_ID</span>=<span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="attr">PRETTY_NAME</span>=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line"><span class="attr">ANSI_COLOR</span>=<span class="string">&quot;0;31&quot;</span></span><br><span class="line"><span class="attr">CPE_NAME</span>=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line"><span class="attr">HOME_URL</span>=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line"><span class="attr">BUG_REPORT_URL</span>=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CENTOS_MANTISBT_PROJECT</span>=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line"><span class="attr">CENTOS_MANTISBT_PROJECT_VERSION</span>=<span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="attr">REDHAT_SUPPORT_PRODUCT</span>=<span class="string">&quot;centos&quot;</span></span><br><span class="line"><span class="attr">REDHAT_SUPPORT_PRODUCT_VERSION</span>=<span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure></li><li>Ubuntu结果<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NAME</span>=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line"><span class="attr">VERSION</span>=<span class="string">&quot;20.04.1 LTS (Focal Fossa)&quot;</span></span><br><span class="line"><span class="attr">ID</span>=ubuntu</span><br><span class="line"><span class="attr">ID_LIKE</span>=debian</span><br><span class="line"><span class="attr">PRETTY_NAME</span>=<span class="string">&quot;Ubuntu 20.04.1 LTS&quot;</span></span><br><span class="line"><span class="attr">VERSION_ID</span>=<span class="string">&quot;20.04&quot;</span></span><br><span class="line"><span class="attr">HOME_URL</span>=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line"><span class="attr">SUPPORT_URL</span>=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line"><span class="attr">BUG_REPORT_URL</span>=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line"><span class="attr">PRIVACY_POLICY_URL</span>=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line"><span class="attr">VERSION_CODENAME</span>=focal</span><br><span class="line"><span class="attr">UBUNTU_CODENAME</span>=focal</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;查看内核版本uname -a; 查看发新版版本cat /etc/os-release。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://xkwang.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++源码编译过程</title>
    <link href="http://xkwang.cn/post/34037422.html"/>
    <id>http://xkwang.cn/post/34037422.html</id>
    <published>2021-03-07T04:40:02.000Z</published>
    <updated>2021-03-07T04:58:11.888Z</updated>
    
    <content type="html"><![CDATA[<p>C++源码编译需要4个步骤 预编译，编译，汇编，链接。</p><a id="more"></a><p>C/C++编译的过程分为<strong>预编译、编译、汇编、链接</strong>四个部分，分别由与编译器，编译器，汇编器和链接器完成。其中各个步骤使用gcc/g++命令和每个步骤的任务如下所示：</p><ol><li>预编译部分完整宏展开，将相关的头文件和宏定义进行展开，头文件以一种类似拷贝的方式包含到被调用的文件中，但又不完全等同于拷贝，宏定义直接进行替换；</li><li>编译部分将C代码转换到汇编代码；</li><li>汇编部分将汇编代码转成目标代码，也就是机器代码；</li><li>最后链接器将各个编译好的文件，以及库文件进行链接，得到可执行文件。</li></ol><p>每个步骤的编译器指令：</p><ol><li>预编译g++ -E file.cpp -o file1</li><li>编译g++ -S file1 -o file2</li><li>汇编g++ -c file2 -o file3</li><li>链接g++ file3 -o file4</li></ol><p>简单的记忆方法，键盘上的ESc字母，就是前两个字母需要大写，最后链接器没有参数。</p><ol><li>编译不需要头文件参与，头文件只是让编译器知道有这样一些成员的存在；</li><li>当执行第n步的转换时，如果没有进行前面步骤的转换，则编译器将自动完成；</li><li>C++采取的时分离式编译过程，只有到最后链接的一步骤才把所有的源文件关联到一起。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++源码编译需要4个步骤 预编译，编译，汇编，链接。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vmware中的网络连接方式</title>
    <link href="http://xkwang.cn/post/89432efe.html"/>
    <id>http://xkwang.cn/post/89432efe.html</id>
    <published>2021-03-07T04:37:51.000Z</published>
    <updated>2021-04-06T15:51:20.621Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机的三种网络模式桥接模式、NAT、host only模式。</p><a id="more"></a><h4 id="虚拟机的三种网络模型结构"><a href="#虚拟机的三种网络模型结构" class="headerlink" title="虚拟机的三种网络模型结构"></a>虚拟机的三种网络模型结构</h4><h4 id="虚拟机的三种网络模型结构-1"><a href="#虚拟机的三种网络模型结构-1" class="headerlink" title="虚拟机的三种网络模型结构"></a>虚拟机的三种网络模型结构</h4><p>最近使用虚拟机，关于网络方面产生了以下的问题：</p><ol><li>PC端开热点的实现原理，目前发现PC端卡热点时win10会产生一个虚拟网卡，该网卡的IP是局域网的网关192.168.137.1/24，同时热点肯定是需要运行NAT协议的；</li><li>交换机，网卡、路由器这些设备运行的协议，这一点需要去参考知乎博客<a href="https://zhuanlan.zhihu.com/p/152330660%E5%8E%BB%E5%AE%9E%E8%B7%B5%EF%BC%9B">https://zhuanlan.zhihu.com/p/152330660去实践；</a></li><li>如果同时连接实验室内网，并且PC机连接了hi WiFi，同时使用笔记本开热点，另一台笔记本接入我的热点，那么笔记本形成了三个局域网，这些局域网构成的网络结构是什么样子；</li><li>机器是如何获取IP的？开启了需要身份认证的WiFi，如果连接了但是没认证是不能上网的，但是获得了IP吗？没有认证是如何获得IP的？</li><li>DHCP服务具体运行原理，静态IP为什么有效？</li><li>实验室的局域网是通过hub式的交换机连接起来的，hub式交换机只能运行数据链路层的协议，那么为什么还需要每个人手动设置静态IP才能访问服务器？</li><li>目前实验室的服务器需要一个单独的锐捷客户端才能上网，能否通过我手边的路由器将局域网和校园网内网连接起来？</li></ol><p>上述这些问题是思考虚拟机网络问题时候想到的，然而能力有限无法一次性解决，等待后续看完《计算机网络自顶向下》再来回答。本篇全部用来解决虚拟机中面临的计算机网络问题。</p><p>本文内容全部来自掘金<a href="https://juejin.cn/post/6844903677912694791">https://juejin.cn/post/6844903677912694791</a> 版本归原作者所有。结合一些自己的思考和实验。<br>实验环境：</p><ol><li>vmware workstation player 16；</li><li>虚拟机系统ubuntu20。<br>vmware提供了三种网络连接模式，桥接模式、NAT模式、host-only模式。</li></ol><p>为了简化问题的考虑，现在不考虑DHCP问题，直接考虑使用静态IP的方式。</p><p>1.桥接模式<br>桥接模式是最简单的模式，其中VMNet0充当了虚拟机局域网的hub交换机，将所有的虚拟机都连接在VMNet0虚拟交换机上，所有虚拟机的IP和宿主机在一个局域网段。这个时候的VMNet0仅仅只是一个交换机，保存有一个mac地址和端口对应的转发表，并不跑IP层协议，因此这个时候VMNet0的IP是无效的，可以随便设置；</p><p>2.NAT模式<br>NAT模式是最复杂的模式，其中VMNet8同时充当了宿主机的虚拟网卡和虚拟机局域网的hub交换机，同时虚拟机内部存在虚拟NAT设备和宿主机的网卡进行通信，实现虚拟机访上网的功能。此外虚拟机局域网内还有虚拟的DHCP服务运行，给每个虚拟机分配动态IP。NAT模式下虚拟机的IP和宿主机物理网卡IP不在一个网段，因此虚拟机上网只能通过虚拟NAT设备实现，虚拟机也不能被宿主机外面的计算机访问。但是宿主机能访问虚拟机，这是通过VMNet8充当的虚拟网卡实现的，这个虚拟网卡的IP和虚拟机局域网在一个网段内；</p><p>3.host-only模式<br>host-only模式是在NAT模式中砍掉虚拟NAT设备，这样虚拟机也不能上网了，只能通过虚拟网卡VMNet8与宿主机通信，但虚拟机内部的虚拟DHCP服务存在，IP是动态获取的。</p><p>从上可以看出，VMnet0在桥接模式下起作用，并且其IP似乎没有任何作用，VMNet8在NAT模式和host-only模式起作用，其IP似乎应该是动态获取的方式，但是实际中发现手动设置VMNet8的IP地址也能正常工作。</p><p>上述问题还有待逐次验证。同时关于如何设置linux的IP获取方式：静态orDHCP将在后续博客中进行展开。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟机的三种网络模式桥接模式、NAT、host only模式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计网" scheme="http://xkwang.cn/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>linux中scp使用</title>
    <link href="http://xkwang.cn/post/221fa5a3.html"/>
    <id>http://xkwang.cn/post/221fa5a3.html</id>
    <published>2021-03-07T04:37:38.000Z</published>
    <updated>2021-03-07T04:38:58.110Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="default" scheme="http://xkwang.cn/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>linux中的rename</title>
    <link href="http://xkwang.cn/post/ec323bcb.html"/>
    <id>http://xkwang.cn/post/ec323bcb.html</id>
    <published>2021-03-07T04:36:54.000Z</published>
    <updated>2021-04-06T16:01:44.346Z</updated>
    
    <content type="html"><![CDATA[<p>rename perl版本将匹配的字符串和替换的字符串放在一个表达式中进行表述。</p><a id="more"></a><p>Linux中文件重命名</p><p>本文关于perl版本rename的部分来自博客  <a href="https://blog.csdn.net/wayne17/article/details/88674459">https://blog.csdn.net/wayne17/article/details/88674459</a>  版权归原作者所有。在评论区也向大佬进行了请教，收获挺多。</p><p>linux中重命名有两种方法：<br>1.使用mv命令，mv命令是移动文件的命令，但同时也可以在移动文件的同时对文件进行重命名操作，但rename只适合单个文件的重命名，对于批量文件重命名无能为力；<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file1 file2 <span class="comment"># 实现单文件重命名</span></span><br></pre></td></tr></table></figure><br>2.使用rename命令<br>rename命令目前有两种实现方式，一种是C语言版，采用通配符进行文件批量重命名，另一种则是Perl语言版，采用正则表达式进行文件批量重命名，也是目前的主流版本。</p><ul><li><p>C语言版重命名十分方便，如要将所有文件的后缀从.txt改为.md，使用如下方式即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename .txt .md *.txt</span><br></pre></td></tr></table></figure><p>其它重命名的操作C语言也类似解决，通配符使用起来很简单方便。</p></li><li><p>Perl语言版是主流是一位Perl版rename支持强大正则表达式<br>Perl版rename使用格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/匹配输入/修改后的/&#x27;</span> 匹配模式</span><br></pre></td></tr></table></figure><p>举例子如下：<br>路径下有test1.txt, test2.txt, test3.txt<br>在每个文件开头加上my_，重命名为my_test1.txt， my_test2.txt， my_test3.txt， my_test4.txt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/^/my_/&#x27;</span> *</span><br></pre></td></tr></table></figure><p>其中^匹配输入开始的位置</p><p>在每个文件结尾添加新的后缀变成.txt.log</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/$/\.log/&#x27;</span> *</span><br></pre></td></tr></table></figure><p>其中$匹配输入结束的位置</p><p>将文件名中第一个t变成大写T</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/t/T/&#x27;</span> *</span><br></pre></td></tr></table></figure><p>将文件命中所有的t变成大写T</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/t/T/g&#x27;</span> *</span><br></pre></td></tr></table></figure><p>后面加了个g代表global，匹配所有的。</p><p>将文件中所有小写字母变成大写字母</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;y/a-z/A-Z/&#x27;</span> *</span><br></pre></td></tr></table></figure><p>注意到前面的s/变成y/，其中s/代表将匹配的部分全部替换，而y/代表将匹配部分逐一替换，从上述可以看出区别。</p><p>其它有关rename Perl语言版的问题就是正则表达式的问题了，可以参考正则表达式的部分<br><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a><br><a href="https://regex101.com/r/V32Npg/1">https://regex101.com/r/V32Npg/1</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;rename perl版本将匹配的字符串和替换的字符串放在一个表达式中进行表述。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://xkwang.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++中的模板编程</title>
    <link href="http://xkwang.cn/post/b829f22b.html"/>
    <id>http://xkwang.cn/post/b829f22b.html</id>
    <published>2021-03-07T04:00:41.000Z</published>
    <updated>2021-03-20T01:25:01.539Z</updated>
    
    <content type="html"><![CDATA[<p>cp是中模板编程是泛型技术实现的基础，包含函数模板和类模板。</p><a id="more"></a><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><ol><li><p>使用template <typename T>或者template <class T>进行类型声明。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1.0</span>,<span class="number">2.0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数模板使用时可以不指定类型，由编译器自动推导，也可以显示指定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一下两种写法均可</span></span><br><span class="line">Max&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line">Max(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></li><li><p>函数模板如果让编译器自动推断类型，必须进行严格类型匹配，不能像普通函数一样进行自动类型转换。如果想要进行自动类型转换，需要显示指定类型。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max(<span class="number">1.0</span>, <span class="number">2</span>); <span class="comment">// 错误，不能自动把2转换成double或者float</span></span><br><span class="line">Max&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>在函数模板和普通函数都能匹配时，优选选择普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;template function!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ordinary function!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ordinary <span class="keyword">function</span>!</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 等价template&lt;class NameType, class AgeType&gt;</span></span><br><span class="line"><span class="comment">// 需要使用多少个类型就用多少类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(NameType name, AgeType age)</span><br><span class="line">  &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;P1(<span class="string">&quot;ali&quot;</span>, <span class="number">90</span>);</span><br><span class="line">  P1.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板派生</p><ol><li>类模板派生普通类，需要指定具体泛型类别；</li><li>类模板派生模板类，继续使用template。</li></ol><h4 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h4><ol><li>类模板不存在自动推导，必须要显示指定类型，因为编译器需要知道占据内存大小；</li><li>类模板可以使用默认参数； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的AgeType默认类型为int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType=<span class="keyword">int</span>&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(NameType name, AgeType age)</span><br><span class="line">  &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。"><a href="#模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。" class="headerlink" title="模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。"></a>模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。</h4>由于模板需要两次编译和C++的分离式编译特点，模板类的声明和实现需要写在一个文件中，否则会出现链接错误，这样的文件后缀为hcpp。</li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>为了防止头文件重复包含，C/C++中使用两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// C/C++语言支持，使用一定没问题</span><br><span class="line"><span class="comment">#ifndefine _TEST</span></span><br><span class="line"><span class="comment">#define _TEST</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 编译器支持，老式编译器不支持</span><br><span class="line"><span class="comment">#pragma once</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;cp是中模板编程是泛型技术实现的基础，包含函数模板和类模板。&lt;/p&gt;</summary>
    
    
    
    
    <category term="STL" scheme="http://xkwang.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++类的基本成员函数</title>
    <link href="http://xkwang.cn/post/1705cf83.html"/>
    <id>http://xkwang.cn/post/1705cf83.html</id>
    <published>2021-03-07T03:56:29.000Z</published>
    <updated>2021-03-07T03:57:09.768Z</updated>
    
    <content type="html"><![CDATA[<p>等待完善</p><a id="more"></a><p>cpp有哪些类方法如果没有定义编译器会自动生成呢？如果没有定义,构造函数，析构函数，拷贝构造函数，赋值运算符重载都会由编译器自动构造，而移动复制构造不会。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;等待完善&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常量运行池</title>
    <link href="http://xkwang.cn/post/53afdded.html"/>
    <id>http://xkwang.cn/post/53afdded.html</id>
    <published>2021-03-07T02:50:07.000Z</published>
    <updated>2021-03-07T02:51:04.291Z</updated>
    
    <content type="html"><![CDATA[<p>等待完善</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;等待完善&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的指针</title>
    <link href="http://xkwang.cn/post/762f2a61.html"/>
    <id>http://xkwang.cn/post/762f2a61.html</id>
    <published>2021-03-07T02:21:20.000Z</published>
    <updated>2021-03-07T02:40:34.800Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++中指针是个非常底层的概念，能够进行的操作（包括破坏力）超乎想象。</p><a id="more"></a><p>问题来源于牛客网的一道题目</p><p>下面代码输出的是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span>*)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(ptr<span class="number">-2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目做的很犹豫，这是到现在第一次看到一个对二维数组求地址的操作，不知道表达啥意思，所以开始做错了。</p><p>可以从升维的角度来看待指针问题，每次取第一个地址，指针的视角就更高了一层。比如，对int取地址，看到了一个int数据的内存，一个一维int数组的地址，看到的是真个数组的内存空间，而一个二维数组的地址，则看到了整个二维数组的内存空间。</p><p>因此，a相当于一个行指针，能够看到二维数组的每一行，那么&amp;a便能看到所有行的空间也就是10个int数据的内存，因此&amp;a+1指针向后移动10个int数据的空间，也即数字10的后面，然后进行类型强制转换将int***转换成int*，因此后续ptr只能看到int内存的大小，于是ptr-2指向9，最终的值也便是9.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++中指针是个非常底层的概念，能够进行的操作（包括破坏力）超乎想象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中文件输入输出</title>
    <link href="http://xkwang.cn/post/7217e645.html"/>
    <id>http://xkwang.cn/post/7217e645.html</id>
    <published>2021-03-06T12:25:54.000Z</published>
    <updated>2021-03-07T00:46:08.779Z</updated>
    
    <content type="html"><![CDATA[<p>C++中文件输入输出主要包含文件输入输出流和文件读写模式的问题。</p><a id="more"></a><h3 id="C-中文件的读写模式"><a href="#C-中文件的读写模式" class="headerlink" title="C++中文件的读写模式"></a>C++中文件的读写模式</h3><p>C++ primer中介绍了C++文件读写的6中模式，但是这些模式具体的作用说的不是很明了，特别是trunc模式被翻译为“截断模式”实在是没理解是啥意思，这里进行总结。</p><table><thead><tr><th>文件模式</th><th>作用</th><th>使用对象</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开</td><td>ifstream, fstream</td></tr><tr><td>ios::out</td><td>为写文件而打开文件，会删除源文件内容，相当于trunc | out</td><td>ofstream, fstream</td></tr><tr><td>ios::app</td><td>以追加方式写文件</td><td>ofstream, fstream</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td><td>ofstream, fstream</td></tr><tr><td>ios::ate</td><td>初始位置在文件末尾</td><td>任意</td></tr><tr><td>ios::binary</td><td>二进制方式读写文件</td><td>任意</td></tr></tbody></table><p>C++中文件输入输出流都有设置默认的模式，ifstream的默认模式是in，ofstream的默认模式是out，fstream的默认模式是in和out。</p><p>如果想要ofstream不覆盖原本文件的内容，要么设置ate模式，要么设置in模式（ofstream可以设置in模式，ifstream也可以设置out模式，但具体作用还有待深究，这里先不纠结）。</p><h3 id="C-中文件输入输出流"><a href="#C-中文件输入输出流" class="headerlink" title="C++中文件输入输出流"></a>C++中文件输入输出流</h3><p>C++中使用流的过程：首先在内存中定义一个流对象，然后将这个流对象与硬盘中的文件关联起来，通过这个流对象操作文件。</p><p>三个基本流fstream，ifstream，ofstream。fstream继承自iostream。<br>流的方法：fstream.open显示地打开文件（创建流对象和文件的关联），fstream.close关闭流对象，fstream.is_open成功打开并且没有关闭返回true否则false。</p><p>流的打开方式：</p><ol><li>构造对象时直接传入string对象或者C风格字符串来代表文件路径；</li><li>先构造对象，先创建文件流对象，后续调用open函数。</li></ol><p>检查流对象是否成功打开是个好习惯，直接用if语句判断流对象即可。</p><h4 id="读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。"><a href="#读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。" class="headerlink" title="读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。"></a>读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。</h4><ol><li>读取整个文件，首先使用ate模式将输入位置指示器移动到文件结尾，再使用tellg获取输入指示器的位置，得到需要构建的内存大小。再使用seekg(0)把输入指示器移动到文件开头，以便对文件进行读取。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p, <span class="built_in">std</span>::ios::ate)</span></span>; <span class="comment">// 先将输入指示器移动到文件结尾</span></span><br><span class="line">    <span class="keyword">if</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> size = input.tellg(); <span class="comment">// 获取输入指示器的位置</span></span><br><span class="line">      input.seekg(<span class="number">0</span>); <span class="comment">// 将输入指示器移动到文件开头</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(size, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(input.read(&amp;str[<span class="number">0</span>], size)) <span class="comment">// 从string对象中获取string字符串的初地址</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>逐行读取文件，使用getline函数即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">      getline(input, str);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>getline会去掉原始文本中的换行符，因此此处加上了endl。结果如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">I am wangxianke from hust</span><br><span class="line">I am glad to hear from you.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是为什么会多出来一个空行呢？我的文件里面没有空行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">I am wangxianke from hust</span><br><span class="line">I am glad to hear from you.</span><br></pre></td></tr></table></figure><p>原因是上述循环代码写的有问题，改为如下就正常。原本代码是在while里面判断input条件，相当于是判断input.eof()，但是当读取到文本最后一行时input.eof返回true，于是还会继续读取一行，但是会读取失败，于是最后就多了个endl换行了。正确的写法不是判断当前是否是eof，而是当前按能否读取成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getline(input, str))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果使用fstream的&gt;&gt;重载那么&gt;&gt;遇到空格便会停止一次读取，最终不是读取一行而是读取每个单词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(input &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">wangxianke</span><br><span class="line">from</span><br><span class="line">hust</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">glad</span><br><span class="line">to</span><br><span class="line">hear</span><br><span class="line">from</span><br><span class="line">you.</span><br></pre></td></tr></table></figure><h4 id="读写二进制文件，使用read和write函数"><a href="#读写二进制文件，使用read和write函数" class="headerlink" title="读写二进制文件，使用read和write函数"></a>读写二进制文件，使用read和write函数</h4><p>写文件就没有必要去区分逐行写还是整个写了，只要流没有关闭，便能不停的写入。</p><p>两种写文件方式，使用二进制写文件或者从文本输出，C++将自动完成编码和解码工作。<br>这里使用二进制方式写入文件和读取文件，便能直接将float和int数据写入文件。<br>当然直接打开Test.b这个文本文件会乱码，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^_&lt;85&gt;&lt;EB&gt;Q&lt;B8&gt;^^       @123abc</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> filename = <span class="string">&quot;Test.b&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">ostrm</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    ostrm.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d), <span class="keyword">sizeof</span> d); <span class="comment">// 二进制输出</span></span><br><span class="line">    ostrm &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                      <span class="comment">// 文本输出</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 回读</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::ifstream <span class="title">istrm</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  istrm.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d), <span class="keyword">sizeof</span> d);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">  istrm &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; read back: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> back: 3.14 123 abc</span><br></pre></td></tr></table></figure><p>需要使用iostream&amp;的地方可以传入fstream，这样只需要少量修改便能将标准输入输出改成文件输入输出。</p><h4 id="文件流的关闭"><a href="#文件流的关闭" class="headerlink" title="文件流的关闭"></a>文件流的关闭</h4><p>一般使用完流对象之后需要及时进行流的关闭。文件流对象会自动的创建和销毁，并且在销毁前会调用close函数。如下函数所示，每次循环都会重新构建文件流对象，在离开每次循环作用域时流对象会被自动销毁，并在销毁前调用构造函数，因此此处不需要手动关闭流对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>; <span class="comment">// 得到每个字符串首地址</span></span><br><span class="line">    <span class="keyword">if</span>(input)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 或者从char*构建string对象以符合cpp风格</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(*p) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">./test file/test1.txt file/test2.txt file/test3.txt file/test5.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中文件输入输出主要包含文件输入输出流和文件读写模式的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="http://xkwang.cn/post/c39717db.html"/>
    <id>http://xkwang.cn/post/c39717db.html</id>
    <published>2021-02-22T00:24:14.000Z</published>
    <updated>2021-02-25T02:16:14.330Z</updated>
    
    <content type="html"><![CDATA[<p>static变量保存在全局数据区，static函数保存在代码区。static起到隐藏、类共享成员作用。</p><a id="more"></a><h4 id="static数据特点"><a href="#static数据特点" class="headerlink" title="static数据特点"></a>static数据特点</h4><ul><li>static变量只被初始化一次，默认初始化为0；</li><li>static变量保存在全局数据区，全局变量作用域具有全局可见性，static全局变量作用域具有文件内可见性，生存周期贯穿整个程序生命周期；static局部变量作用域具有局部可见性，生存周期也是贯穿整个程序生命周期，但是出了局部作用域便不可见；</li><li>static函数保存在代码区。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量放在全局数据区</span></span><br><span class="line">    <span class="comment">// 静态函数放在代牧区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x408024</span></span><br><span class="line">             &lt;&lt;&amp;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x408028</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x401410 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x40143e 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x40146c 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f4&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x40149a 占2e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类外static起到隐藏作用"><a href="#类外static起到隐藏作用" class="headerlink" title="类外static起到隐藏作用"></a>类外static起到隐藏作用</h4></li><li>分离式编译中隐藏其它文件的全局变量</li><li>分离式编译中隐藏其它文件的全局函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world 2&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    f1(); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: conflicting specifiers in declaration of &#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="comment">// error: conflicting specifiers in declaration of &#x27;f2&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>至于隐藏的原理，后续在补充，还没看到相关博客内容</li></ul><h4 id="类内static成员"><a href="#类内static成员" class="headerlink" title="类内static成员"></a>类内static成员</h4><ul><li>类的静态数据成员，静态函数成员属于整个类而非对象，没有隐式的指针，因此静态成员函数不能声明为const，只能访问静态数据成员和静态函数成员；</li><li>静态成员函数不能为虚函数（虚函数存在this指针动态绑定过程）；</li><li>静态成员存储空间在类的存储空间外；</li><li>静态成员在类外初始化，在类内声明。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;static变量保存在全局数据区，static函数保存在代码区。static起到隐藏、类共享成员作用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中char的地址</title>
    <link href="http://xkwang.cn/post/a19b496f.html"/>
    <id>http://xkwang.cn/post/a19b496f.html</id>
    <published>2021-02-21T12:44:33.000Z</published>
    <updated>2021-02-23T05:49:53.332Z</updated>
    
    <content type="html"><![CDATA[<p>打印char a地址需要使用<code>std::cout&lt;&lt;(void*)&amp;a</code>进行，因为&amp;a类型是char*，对于char* std::cout会认为是字符串起始地址，因此会输出从起始地址到’\0’的字符串。而char的存储空间无’\0’字符，因此<code>std::cout&lt;&lt;&amp;a</code>会访问到非法内存，输出乱码。如需打印地址需要进行类型转换。</p><a id="more"></a><p>对于函数指针的打印也需要先类型转换成void*，因为函数指针没有对&lt;&lt;运算符重载，会导致函数指针自动转换成bool类型，从而打印1。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打印char a地址需要使用&lt;code&gt;std::cout&amp;lt;&amp;lt;(void*)&amp;amp;a&lt;/code&gt;进行，因为&amp;amp;a类型是char*，对于char* std::cout会认为是字符串起始地址，因此会输出从起始地址到’\0’的字符串。而char的存储空间无’\0’字符，因此&lt;code&gt;std::cout&amp;lt;&amp;lt;&amp;amp;a&lt;/code&gt;会访问到非法内存，输出乱码。如需打印地址需要进行类型转换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++四种类型转换的区别</title>
    <link href="http://xkwang.cn/post/158a3f9d.html"/>
    <id>http://xkwang.cn/post/158a3f9d.html</id>
    <published>2021-02-21T12:34:26.000Z</published>
    <updated>2021-03-01T14:38:45.096Z</updated>
    
    <content type="html"><![CDATA[<p>C++四种类型转换，static_cast编译时进行，下行转换不安全，dynamic_cast运行时进行，下行转换安全，const_cast可用于去除const，谨慎使用，reinterpret_cast从底层二进制进行转换，无所不能，不到万不得以不能用。</p><a id="more"></a><h4 id="四种类型转换的使用"><a href="#四种类型转换的使用" class="headerlink" title="四种类型转换的使用"></a>四种类型转换的使用</h4><p><b>static_cast</b><br>下行转换：基类 –&gt; 派生类转换<br>上行转换：派生类–&gt;基类转换<br>编译时进行类型转换<br>应用</p><ul><li>上行转换安全，下行转换不安全，可能造成非法内存访问；</li><li>一般常见的其它类型转换</li></ul><p><b>dynamic_cast</b><br>运行时进行类型转换，被转换对象需要有虚函数进行运行时类型判别。<br>相比较于static_cast，dynamic_cast的下行转换安全，如果转换失败返回空指针。</p><p><b>const_cast</b><br>const_cast可以进行 <b>const对象–&gt;非const类型转换</b>  和 <b>非const类型转换–&gt;const类型</b>转换两种类型。唯一一个可以对const对象进行使用的转换，使用需要谨慎，防止修改了const对象。典型应用场景是底层const类型的函数重载。</p><p>一个危险的使用方式，通过const_cast之后改变了通过b改变了a原始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b=a;</span><br><span class="line"><span class="keyword">auto</span> &amp;c=<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(b);<span class="comment">//必须要指定引用，详情看auto使用</span></span><br><span class="line">c=<span class="number">1</span>; <span class="comment">//a的值变为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b=a;</span><br><span class="line"><span class="keyword">auto</span> &amp;c=<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(b);</span><br><span class="line">c=<span class="number">1</span>; <span class="comment">//a的值还是0</span></span><br></pre></td></tr></table></figure><br>一个正常的使用方式，用作const底层重载的参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;const function&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> s1.size()&lt;s2.size()?s1: s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not const function&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> s1.size()&lt;s2.size()?s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;result1=shorterString(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello world&quot;</span>); <span class="comment">// 调用const function</span></span><br><span class="line">  string s1(&quot;hello&quot;), s2(&quot;hello world&quot;);</span><br><span class="line">  <span class="keyword">auto</span> &amp;result2=shorterString(s1, s2); <span class="comment">// 调用not const function</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;result3=shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2)); <span class="comment">//调用const function</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;result4=<span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(result3); <span class="comment">//恢复可变性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><b>reinterpret_cast</b><br>最不安全，从底层二进制进行类型转换，依赖于平台，十分危险不能使用，可以进行任意类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> *b=<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++四种类型转换，static_cast编译时进行，下行转换不安全，dynamic_cast运行时进行，下行转换安全，const_cast可用于去除const，谨慎使用，reinterpret_cast从底层二进制进行转换，无所不能，不到万不得以不能用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类内存字节对齐</title>
    <link href="http://xkwang.cn/post/30f3ce8a.html"/>
    <id>http://xkwang.cn/post/30f3ce8a.html</id>
    <published>2021-02-21T09:56:17.000Z</published>
    <updated>2021-02-22T10:00:06.856Z</updated>
    
    <content type="html"><![CDATA[<p>内存对齐的两个基本原则是首地址偏移量需要是min（对齐单位，成员字节数）的倍数，总字节数需要是对齐单位倍数。</p><a id="more"></a><p>本文内容参考 <a href="https://zhuanlan.zhihu.com/p/30007037">https://zhuanlan.zhihu.com/p/30007037</a><br>版权归<a href="https://www.zhihu.com/people/qinlibo_nlp">忆臻</a>所有。</p><h3 id="内存对齐的必要性"><a href="#内存对齐的必要性" class="headerlink" title="内存对齐的必要性"></a>内存对齐的必要性</h3><p>虽然内存以字节为单位进行保存，但处理器寄存器一次性读取数据可能按照双字节、4字节、8字节等进行读取。32位系统的存取粒度是4字节，64位系统的存取力度是8字节。考虑32位系统下从地址1开始存放一个int，那么处理器需要读取两次数据，并且经过两次移位，一次拼接完成int的读取，这些导致数据读取速度的下降。内存对齐牺牲一定的存储空间，来换取更快的内存访问速度。</p><h3 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h3><h4 id="对齐模数"><a href="#对齐模数" class="headerlink" title="对齐模数"></a>对齐模数</h4><ul><li>对齐模数：每个平台下的不同编译器都有自己默认的对齐模数，win 64 gcc32的默认对齐模数是8，centos64 gcc64默认对齐模数也是8。可以通过预编译命令#pragma pack(n)进行修改；</li><li>对齐单位：min（对齐模数，max（类中数据成员字节数））</li></ul><h4 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h4><ol><li>第一个类成员首地址offset为0，之后每个成员首地址offset是<strong>min（对齐单位，该成员字节数）的整数倍</strong>，如有需要编译器会进行字节填充；</li><li>类总字节数是<strong>对齐单位</strong>整数倍，如有需要编译器会进行字节填充。</li></ol><p>例子（win10 gcc32 环境，默认对齐模数是8）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="keyword">char</span> z; <span class="comment">// 类B中占据8 Bytes,作为类C成员占据4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B b; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1c</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 24 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32 Bytes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B的内存分布 24字节</p><p>| 虚表指针4字节 | x 4字节 | y 8字节 | z 1字节 <strong>填充7字节</strong> |</p><p>C的内存分布 32字节</p><p>| C的虚表指针4字节 | B的虚表指针4字节 | B::x 4字节 <strong>填充4字节</strong> | B::y 8字节 | B::z 1字节 <strong>填充7字节</strong> |</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存对齐的两个基本原则是首地址偏移量需要是min（对齐单位，成员字节数）的倍数，总字节数需要是对齐单位倍数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++空白基类最优化</title>
    <link href="http://xkwang.cn/post/7f1322f0.html"/>
    <id>http://xkwang.cn/post/7f1322f0.html</id>
    <published>2021-02-21T09:26:04.000Z</published>
    <updated>2021-02-24T05:36:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>空白基类最优化（EBO empty base optimization 或 EBCO empty base class optimization）空类作为类成员是按照类内字节对齐方式占据内存，作为继承基类时在子类中占据字节被优化为0。</p><a id="more"></a><p>EBCO参考<a href="https://en.cppreference.com/w/cpp/language/ebo%E3%80%82">https://en.cppreference.com/w/cpp/language/ebo。</a></p><ul><li>mingw32环境下的EBO  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization applies</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;; <span class="comment">// empty class 1 Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base &#123; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>如果空基类也是第一个非静态数据成员的类型或类型的基类，则禁止进行空基优化，因为同一类型的两个基子对象需要在<strong>最派生类型</strong>的对象表示中具有不同的地址。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization does not apply,</span></span><br><span class="line"><span class="comment">// base occupies 1 byte, Base member occupies 1 byte</span></span><br><span class="line"><span class="comment">// followed by 2 bytes of padding to satisfy int alignment requirements</span></span><br><span class="line"><span class="comment">// | Base 1 Byte | Base 1 Byte | 2 Bytes | i 4 Bytes |</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base &#123; <span class="comment">// 8 Bytes</span></span><br><span class="line">    Base c; <span class="comment">// Base, occupies 1 byte, followed by padding for i</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization does not apply,</span></span><br><span class="line"><span class="comment">// base takes up at least 1 byte plus the padding</span></span><br><span class="line"><span class="comment">// to satisfy alignment requirement of the first member (whose</span></span><br><span class="line"><span class="comment">// alignment is the same as int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// | Base 1 Byte | 3 Bytes | c 4 Bytes | i 4 Bytes |</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived3</span> :</span> Base &#123; <span class="comment">// 12 Bytes</span></span><br><span class="line">    Derived1 c; <span class="comment">// derived from Base, occupies sizeof(int) bytes</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>多继承，继承链中只要满足<strong>第一个非静态数据成员的类型或类型的基类不是空基类</strong>，照样进行空基优化。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass2</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> EmptyClass1&#123; <span class="comment">// 4 Bytes</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> EmptyClass1, <span class="keyword">public</span> EmptyClass2&#123; <span class="comment">// 4 Bytes</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived3</span>:</span> <span class="keyword">public</span> Derived1&#123; <span class="comment">// 8 Bytes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived4</span>:</span> <span class="keyword">public</span> Derived2&#123; <span class="comment">// 8 Bytes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;空白基类最优化（EBO empty base optimization 或 EBCO empty base class optimization）空类作为类成员是按照类内字节对齐方式占据内存，作为继承基类时在子类中占据字节被优化为0。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的虚函数</title>
    <link href="http://xkwang.cn/post/fa71210a.html"/>
    <id>http://xkwang.cn/post/fa71210a.html</id>
    <published>2021-02-21T08:02:12.000Z</published>
    <updated>2021-03-07T02:43:20.638Z</updated>
    
    <content type="html"><![CDATA[<p>关于C++中的虚函数，两篇博客讲的很清楚，尤其是第一篇。<br><a href="https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA">https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA</a><br><a href="https://juejin.cn/post/6844903666667749389">https://juejin.cn/post/6844903666667749389</a><br>本文主要关注如何通过对象地址去调用虚函数。</p><a id="more"></a><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::g&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::h&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Fun pFun=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span>*)(&amp;b)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b)+<span class="number">1</span>));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b)+<span class="number">2</span>));</span><br><span class="line">  pFun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0x7ffe5355fb78<br>Base::f<br>Base::g<br>Base::h<br>其中a=（long*)(&amp;b)是虚表地址，long*(*a)是第一个虚函数地址。之所以需要转换为long*，是因为C++64位环境中指针占据8字节（同long，long*），这样后续的+1便能明确是将指针移动8字节，得到下一个虚函数的地址。</p><p>但是还有个疑问，上述写法(long*)*(long*)(&amp;b)是第一个虚函数地址，+1后得到第二个虚函数地址有点奇怪，因为第一个虚函数的代码占据代码区空间不一定是8字节，为什么加1就是第二个虚函数地址呢？相反，应该说虚表的第二个元素存储第二个虚函数地址，按道理应该按照下面的写，但是下面的写法是错误的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::g&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::h&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Fun pFun=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span>*)(&amp;b)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*(<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)(&amp;b)+<span class="number">1</span>);</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*(<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)(&amp;b)+<span class="number">2</span>);</span><br><span class="line">  pFun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0x7ffd0e186818<br>Base::f<br>Segmentation fault (core dumped)</p><p>仔细思考下，自己想错了，这个要仔细画图去体会</p><div style="text-align: center"><img src="/assets/blog/fa71210a/vtable.jpg" margin="0 auto" width="50%" height="50%"/></div><p>从图中可以看出，long*(&amp;b)是对象成员的首地址，也就是虚表指针的首地址，*(long*)(&amp;b)得到对象第一个成员的值，也就是虚表的地址，还是一样，进行类型强转，因此为(long*)*(long*)(&amp;b)。至此，虚表的首地址得到，为p=(long*)*(long*)(&amp;b)，那么+1，+2，+3为虚表后续元素的地址，*(p+n)便得到第n+1个虚函数的地址，为了进行函数调用，进行类型强转，变为函数指针，因此为(Fun)*(p+n)，便得到代码1的结果。</p><p>代码2中(long*)(&amp;b)+n得到的是第n+1个数据成员地址，而Base对象只有一个虚表指针成员，因此后续代码造成了非法内存访问，于是出现段错误。</p><p>还有个问题是如果编程时明确指定了派生类调用基类的同名函数，如p-&gt;A::func那么func的类型在编译时便能确定，调用的就是基类的函数，也就不存在动态绑定的问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于C++中的虚函数，两篇博客讲的很清楚，尤其是第一篇。&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA&quot;&gt;https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/6844903666667749389&quot;&gt;https://juejin.cn/post/6844903666667749389&lt;/a&gt;&lt;br&gt;本文主要关注如何通过对象地址去调用虚函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>decltype和auto的比较</title>
    <link href="http://xkwang.cn/post/e85c9ea6.html"/>
    <id>http://xkwang.cn/post/e85c9ea6.html</id>
    <published>2021-02-20T13:21:37.000Z</published>
    <updated>2021-03-03T14:49:51.979Z</updated>
    
    <content type="html"><![CDATA[<p>auto和decltype称为占位符，在编译时进行自动类型推断。</p><a id="more"></a><h4 id="auto使用的几点注意"><a href="#auto使用的几点注意" class="headerlink" title="auto使用的几点注意"></a>auto使用的几点注意</h4><ol><li>auto从给定初值中进行类型推断，使用auto的表达式同时完成定义和初始化；</li><li>auto支持一行语句定义多个变量，但需要类型相同。注意&amp;和*非基本数据类型； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a; <span class="comment">// 正确 auto类型推断为int</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;a; <span class="comment">// 正确，auto推断类型为int*</span></span><br><span class="line"><span class="keyword">auto</span> *d1=&amp;a; <span class="comment">// 正确，auto推断类型也是int*，auto推断可以看出很灵活</span></span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a, d=&amp;a; <span class="comment">// 错误 前两个auto推断为int,后面为int*</span></span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a, *d=&amp;a;<span class="comment">// 正确 auto全部推断为int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> x=a, y=m, *z=&amp;m; <span class="comment">// x,y均int，但&amp;z是const int类型，error</span></span><br></pre></td></tr></table></figure></li><li>使用引用时参与初始化的是引用对象的值，而非引用对象本身； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">// b类型int而非const int &amp;</span></span><br></pre></td></tr></table></figure></li><li>auto一般会忽略顶层const，保留底层const。如果希望保留顶层const，需要自行在auto前添加const； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">// b int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> c=a; <span class="comment">// c是const int a，const属性自己添加。</span></span><br></pre></td></tr></table></figure></li><li>设置类型为auto引用或auto指针时，初始值中的顶层const属性得到保留。因为对const取引用或者取地址一定是底层const。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;b=a, *c=&amp;a; <span class="comment">// b为const int &amp;, c为const int *</span></span><br></pre></td></tr></table></figure>关于auto以下几条肯定成立：</li></ol><ul><li>不能用作函数参数。auto需要编译时确定类型，但是函数编译时不能进行形式结合，无法判定类型；</li><li>auto不能用作类的非静态成员，只有类的静态成员才具有初值（要么默认的0，要么类外初始化），类的普通成员编译时不能得到具体参数；</li><li><h4 id="decltype使用的几点注意"><a href="#decltype使用的几点注意" class="headerlink" title="decltype使用的几点注意"></a>decltype使用的几点注意</h4></li></ul><ol><li>decltype使用表达式的类型进行推断，并不实际计算表达式（也不调用函数）；</li><li>如果decltype使用的是变量，返回变量的类型，包含引用和顶层const；</li><li>如果decltype使用的表达式不是变量，返回表达式的结果对应类型； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b=a;</span><br><span class="line"><span class="keyword">decltype</span>(b) c; <span class="comment">// 类型int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(b+<span class="number">1</span>) d; <span class="comment">//类型int</span></span><br></pre></td></tr></table></figure></li><li>decltype内部如果使用括号结果一定是引用。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;auto和decltype称为占位符，在编译时进行自动类型推断。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>new和malloc的区别</title>
    <link href="http://xkwang.cn/post/c69e57ea.html"/>
    <id>http://xkwang.cn/post/c69e57ea.html</id>
    <published>2021-02-20T11:47:27.000Z</published>
    <updated>2021-03-03T23:40:23.224Z</updated>
    
    <content type="html"><![CDATA[<p>new和malloc的10点区别。本文内容参考<a href="https://www.cnblogs.com/QG-whz/p/5140930.html%E3%80%82">https://www.cnblogs.com/QG-whz/p/5140930.html。</a></p><a id="more"></a><ol><li>new是C++的关键字，需要编译器提供支持（当然都支持）；malloc是库函数，需要include&lt;malloc.h&gt;的头文件；</li><li>new是C++的运算符，支持重载，而malloc不支持；</li><li>new分配内存是在自由存储区，自由存储区是个抽象概念，详情参考<a href="8f50d358.html">C++的存储结构</a>。而malloc分配内存是在堆区；</li><li>new分配内存失败会返回bad_alloc异常，而mallc失败返回NULL；</li><li>new返回类型安全，是指向对象的指针，而malloc返回类型不安全，是一个(void*)指针，需要用户进行强制类型转换；</li><li>new会调用对象的构造函数，在内存空间中构造每个数据成员，而malloc不会调用构造函数，只是返回一个指向原始内存空间的指针，因此，OOP中不适合使用malloc。同理，delete会调用析构函数，而free不会；</li><li>new不需要显示确定每个对象的大小，编译器会自行计算，而malloc需要使用sizeof运算符显示指出；</li><li>new内部可以通过调用malloc实现，但是反过来不行；</li><li>malloc存在直观的重新分配内存方式realloc，new不存在直观的方式；</li><li>new抛出异常之前先去执行用户指定的错误处理函数，具体可以由用户控制，malloc只能返回NULL，无其它能做的事情。</li></ol><p>关于C++ free函数是如何判断内存空间的大小？<br>现代C++编译器在使用malloc分配内存时，将内存大小存放在分配内存前面的地址空间内，对于每个编译器其值固定。这样free是通过当前指针便能找到占用内存大小，从而确定free内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;new和malloc的10点区别。本文内容参考&lt;a href=&quot;https://www.cnblogs.com/QG-whz/p/5140930.html%E3%80%82&quot;&gt;https://www.cnblogs.com/QG-whz/p/5140930.html。&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的this指针</title>
    <link href="http://xkwang.cn/post/5082990a.html"/>
    <id>http://xkwang.cn/post/5082990a.html</id>
    <published>2021-02-20T09:16:53.000Z</published>
    <updated>2021-02-23T05:10:12.509Z</updated>
    
    <content type="html"><![CDATA[<p>C++中this指针是隐式的成员函数参数，类似python中的self，当访问数据成员或者函数成员时就会把对象的首地址赋值给this指针。this指针指向对象存储空间的首地址，也即第一个数据成员的首地址。因此，this指针不占据对象存储空间。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">location</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1,x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff0f</span></span><br><span class="line">    b.location(); <span class="comment">// 0x61ff0f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b.x1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff08</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b.x2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff0c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中this指针是隐式的成员函数参数，类似python中的self，当访问数据成员或者函数成员时就会把对象的首地址赋值给this指针。this指针指向对象存储空间的首地址，也即第一个数据成员的首地址。因此，this指针不占据对象存储空间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类和对象的存储结构</title>
    <link href="http://xkwang.cn/post/8f50d358.html"/>
    <id>http://xkwang.cn/post/8f50d358.html</id>
    <published>2021-02-20T09:01:31.000Z</published>
    <updated>2021-02-25T00:38:45.717Z</updated>
    
    <content type="html"><![CDATA[<p>C++内存结构分为代码区，数据区和栈区。代码区存放编译的机器指令；数据区又分为堆区和全局数据区，其中堆区存放malloc出来的内存，全局数据区存放全局变量和静态变量；栈区存放自动变量，由编译器分配和释放。</p><a id="more"></a><h4 id="C-C-存储空间结构"><a href="#C-C-存储空间结构" class="headerlink" title="C/C++存储空间结构"></a>C/C++存储空间结构</h4><div style="text-align: center"><img src="/assets/blog/8f50d358/memory.jpg" margin="0 auto" width="50%" height="50%"/></div><blockquote><p>BSS: Block Started by Symbol，意为“以符号开始的块”。在C语言中还分：未初始化的全局变量和静态变量、已初始化的全局变量和静态变量。但是在C++中没有这个区分，他们共同占用同一块内存区。代码区和数据区内存数据从可执行文件中读取。</p></blockquote><ol><li>代码区：存放CPU执行的机器指令，代码区是可共享，并且是只读的；</li><li>数据区（全局/静态存储区）：存放已初始化的全局变量、静态变量（全局和局部）、常量数据；<ul><li>BBS区：存放未初始化的全局变量和静态变量；</li><li>GVAR区：存放已经初始化的全局变量和静态变量；</li></ul></li><li>栈区：由编译器自动分配释放，存放函数的参数值、返回值和局部变量，在程序运行过程中实时分配和释放，栈区由操作系统自动管理，无须程序员手动管理；</li><li>堆区：堆是由malloc()函数分配的内存块，使用free()函数来释放内存，堆的申请释放工作由程序员控制；</li><li><strong>自由存储区</strong>：由new分配的内存块都是自由存储区，是C++中才有的抽象概念。自由存储区不是一个具体的物理概念，对应的物理存储区可能是堆区，也可能是静态存储区，需要看不同编译器new的实现方式。</li></ol><p>new和malloc的区别参考<a href="c69e57ea.html">new和malloc区别</a>。</p><h3 id="基本数据类型占据内存大小"><a href="#基本数据类型占据内存大小" class="headerlink" title="基本数据类型占据内存大小"></a>基本数据类型占据内存大小</h3><p>32、64位编译器不同数据类型占据内存字节数如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">32位</th><th align="center">64位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center"><strong>long</strong></td><td align="center"><strong>4</strong></td><td align="center"><strong>8</strong></td></tr><tr><td align="center">long long</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center"><strong>指针</strong></td><td align="center"><strong>4</strong></td><td align="center"><strong>8</strong></td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr></tbody></table><h3 id="C-类和对象的存储"><a href="#C-类和对象的存储" class="headerlink" title="C++类和对象的存储"></a>C++类和对象的存储</h3><h4 id="C-类的构成："><a href="#C-类的构成：" class="headerlink" title="C++类的构成："></a>C++类的构成：</h4><p>数据成员：非静态的内置类型、对象类型，静态数据成员<br>函数成员：非虚函数，虚函数</p><blockquote><p>静态数据成员不与任何对象绑定，即不存在隐含的this指针，存放在堆区。静态成员函数不能声明成const（没有隐含的this指针），也不能在其内部使用this指针。</p></blockquote><ol><li>静态数据成员不占对象存储空间；</li><li>内置类型占据空间<a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">如上</a>；</li><li>对象数据类型占据空间按照类内存对齐原则；</li><li>非虚函数不占内存；</li><li>虚函数存在虚函数指针占据内存。</li></ol><blockquote><p>类类型对齐原则是指在牺牲一定空间损失的情况下，换取内存读取次数的减少。详情参考<a href="30f3ce8a.html">C++类内字节对齐</a>。</p></blockquote><p>不保存函数成员的考虑：OOP编程其中一个目的就是代码重用，相同类不同对象的函数成员没有必要给每个对象保存，放置在公共区能节省内存。对象调用成员函数时通过域作用符和函数名便能寻址，然后把对象名传递给隐式的this指针便能分辨具体调用的是哪个对象。</p><p>虚函数通过虚表实现，包含虚函数的对象有一个指向虚表的指针，这个指针占据内存。</p><p>有关this的详细介绍参考<a href="5082990a.html">this指针</a>。<br>有关虚函数的详细介绍参考<a href="fa71210a.html">虚函数</a>。</p><h4 id="空白类对象占据1字节"><a href="#空白类对象占据1字节" class="headerlink" title="空白类对象占据1字节"></a>空白类对象占据1字节</h4><p>是为了不同实例之间的区分。空白类也能实例化，为了区分每个对象需要具有不同地址，因此至少得分配1字节内存。在继承时，如果基类是空白类，那么子类继承父类的那1个字节会被优化掉，变为0，成为空白基类最优化，参见<a href="7f1322f0.html">空白基类最优化</a>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在win10 gcc32环境下类A占据内存8字节，类B占据内存24字节，类C占据内存32字节，类X占据内存8字节，如代码中注释。但在centos 64, gcc64环境下类A占据内存16字节，类B占据内存32字节，类C占据内存48字节，类X占据内存8字节。centos 64, gcc64环境的默认对齐系数也是8，但指针是8字节，造成了不同。</p><p>内存对齐会导致对象占据的空间比单个数据占据空间之和多，关于对象内存字节对齐，参考<a href="30f3ce8a.html">C++类内存对齐</a>。对象成员内存分布的先后顺序会影响内存对齐，虚表指针始终是对象内存空间的首元素，关于C++对象虚表的存储模型，参考<a href="fa71210a.html">C++虚函数</a>。排在第二的是从父类继承来的成员，最后是子类自己非继承、非虚表指针数据成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8) <span class="comment">//win10, mingw32的默认对齐模数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1a</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m; <span class="comment">// 这里只是声明, 没有定义, 需要类外定义(分配内存)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> X::m; <span class="comment">// 类外进行静态成员定义 否则运行时错误undefined reference</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="keyword">char</span> z; <span class="comment">// 类B中是8 Bytes,作为类C成员是4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    B b; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1c</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 24 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8 Bytes 有无static int m无影响 m放在全局数据区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;X::m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0 静态成员只进行一次初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++内存结构分为代码区，数据区和栈区。代码区存放编译的机器指令；数据区又分为堆区和全局数据区，其中堆区存放malloc出来的内存，全局数据区存放全局变量和静态变量；栈区存放自动变量，由编译器分配和释放。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中main函数参数</title>
    <link href="http://xkwang.cn/post/50d4ff1a.html"/>
    <id>http://xkwang.cn/post/50d4ff1a.html</id>
    <published>2021-02-20T08:40:09.000Z</published>
    <updated>2021-02-23T05:48:09.264Z</updated>
    
    <content type="html"><![CDATA[<p>C++ main函数带参数声明为<code>int main(int argc, char* argv[])</code>。第一个参数代表参数个数，第二个参数代表参数字符串数组。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//compile, g++ test.cpp -o test</span></span><br><span class="line"><span class="comment">//running, ./test 1 2.0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// sizeof(argv) will return the pointer size instead of array size like array!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(argv)/<span class="keyword">sizeof</span>(argv[<span class="number">0</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argc&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the origin strings</span></span><br><span class="line">    <span class="comment">// &quot;C:\Users\25411\Desktop\test\test.exe&quot; &quot;1&quot; &quot;2.0&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;argc; ++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert strings to proper type atoi, ascii to int  </span></span><br><span class="line">    <span class="comment">// atof, ascii to float</span></span><br><span class="line">    <span class="comment">// atol, atoll</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[<span class="number">0</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &quot;C:\Users\25411\Desktop\test\test.exe&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;atoi(argv[<span class="number">1</span>])&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;atof(argv[<span class="number">2</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ main函数带参数声明为&lt;code&gt;int main(int argc, char* argv[])&lt;/code&gt;。第一个参数代表参数个数，第二个参数代表参数字符串数组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++访问权限控制关键字</title>
    <link href="http://xkwang.cn/post/b61a0d65.html"/>
    <id>http://xkwang.cn/post/b61a0d65.html</id>
    <published>2021-02-20T05:37:33.000Z</published>
    <updated>2021-02-23T05:11:38.159Z</updated>
    
    <content type="html"><![CDATA[<p>C++权限控制关键字包含public, private,  protected。</p><a id="more"></a><h3 id="从类自身去看"><a href="#从类自身去看" class="headerlink" title="从类自身去看"></a>从类自身去看</h3><ul><li>public类内和类外均可访问</li><li>private只能类内访问（特殊情况要访问使用友元类或者友元函数）</li><li>protected只能类内访问</li></ul><h3 id="从继承关系去看"><a href="#从继承关系去看" class="headerlink" title="从继承关系去看"></a>从继承关系去看</h3><h4 id="简单情况下"><a href="#简单情况下" class="headerlink" title="简单情况下"></a>简单情况下</h4><ul><li>public属性的成员和函数都可被子类访问</li><li>private属性的成员和函数不可被子类访问</li><li>protected属性的成员和函数可以被子类访问</li></ul><p><a href="#%E4%BB%A3%E7%A0%811">实验代码</a></p><p>虽然private属性成员不能被子类访问，但是子类中存在这些成员，只是被隐藏了。<a href="#%E4%BB%A3%E7%A0%812">实验代码</a></p><h4 id="公有继承、私有继承、保护继承"><a href="#公有继承、私有继承、保护继承" class="headerlink" title="公有继承、私有继承、保护继承"></a>公有继承、私有继承、保护继承</h4><blockquote><p>子类继承父类格式 class Child: [继承权限] Base1, [继承权限]Base2, … 其中继承权限分为3种。</p></blockquote><p>三种继承方式，在子类内部，父类成员的访问级别与父类相同，改变的只是用户代码（类外）的访问级别。</p><ul><li>public继承，继承之后子类外部访问父类成员权限不变；</li><li>private继承，继承之后子类外部访问父类成员权限全部变为private;</li><li>protected继承，继承之后子类外部访问父类成员public变成protected（可以进一步被继承使用），private还是private，protected还是protected。</li></ul><p>C++的权限控制保证了一般情况下用户代码（类外）不能访问private和protected的成员，子类不能访问父类private成员，子类能够访问父类protected成员。</p><h3 id="默认权限级别"><a href="#默认权限级别" class="headerlink" title="默认权限级别"></a>默认权限级别</h3><ul><li>class默认的权限级别是private，struct默认的权限级别是public。</li><li>继承的权限级别默认是private。</li></ul><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print1 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print2 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print3 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:</span> <span class="keyword">public</span> Child1&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// constructor must be public</span></span><br><span class="line">    Child2(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        x2=x3=x;</span><br><span class="line">        x1=x; <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Child1 d1;</span><br><span class="line">    d1.print3();</span><br><span class="line">    d1.x3=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    d1.print1(); <span class="comment">// error, declared private here</span></span><br><span class="line">    d1.x1=<span class="number">0</span>; <span class="comment">// error, declared private here</span></span><br><span class="line"></span><br><span class="line">    d1.print2(); <span class="comment">// error, declared protected here</span></span><br><span class="line">    d1.x2=<span class="number">0</span>; <span class="comment">// error, declared protected here</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Child2 <span class="title">d2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    d2.print2(); <span class="comment">// error</span></span><br><span class="line">    d2.x2=<span class="number">0</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print1 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1; <span class="comment">// 4 </span></span><br><span class="line">    <span class="keyword">float</span> x2; <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Child1 d1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d1)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是8的原因可以参考<a href="8f50d358.html">C++类和对象的存储结构</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++权限控制关键字包含public, private,  protected。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OOP的三大特性</title>
    <link href="http://xkwang.cn/post/d91bc6a5.html"/>
    <id>http://xkwang.cn/post/d91bc6a5.html</id>
    <published>2021-02-20T04:03:03.000Z</published>
    <updated>2021-03-04T11:57:08.245Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程（OOP）的三大特性：封装、继承、多态。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>封装</strong>是指对象把自己的数据成员和对数据的操作封装在一起；<br><strong>继承</strong>是指子类（派生类）对父类（基类）的继承，子类把父类的数据和对数据的操作继承过来，同时又增添了自己的数据和对数据的操作；<br><strong>多态</strong>同一操作作用于不同对象，产生不同结果。主要体现为函数重载（静态多态，编译时确定）和虚函数（动态多态，运行时确定）。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承权限问题 参看<a href="b61a0d65.html">C++权限控制</a>；</li><li>继承带来的重写、重载、虚函数，后续介绍；</li><li>C++的多继承、菱形继承，后续补充。</li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>函数重载<br>相同函数名字，不同参数列表（含不同数量参数、不同种类参数）或const函数</li><li>运算符重载<br>相同的运算符作用于不同对象，产生不同结果。通过operator函数实现。</li></ul><p><strong>重写是指子类继承父类成员函数，但是对父类函数进行了重新实现，子类重写父类函数之后没办法直接访问到父类同名函数</strong></p><blockquote><p>与Java中可以通过super访问到父类不同，Java只允许单继承，因此super可以很唯一的指向父类，C++支持多继承，父类可能不止一个。因此，在C++中如果要在子类中访问父类的方法，只能用class::function()的方式进行。</p></blockquote><p>重写、重载、虚函数是设计继承需要考虑的问题。重写之后原来父类的方法子类不能访问；重载则子类可以访问父类的同名成员函数；重写会覆盖父类函数，重载则每个子类必须由自身对象进行调用，无法根据运行时进行灵活选择，因此有了虚函数的概念。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>子类中出现了和父类相同名字的虚函数也是一种重写，子类重写了父类的虚函数，有关虚函数的细节参考<a href="fa71210a.html">C++中的虚函数</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象编程（OOP）的三大特性：封装、继承、多态。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客使用方法</title>
    <link href="http://xkwang.cn/post/782b19c0.html"/>
    <id>http://xkwang.cn/post/782b19c0.html</id>
    <published>2021-02-20T03:57:23.000Z</published>
    <updated>2021-02-20T03:59:15.518Z</updated>
    
    <content type="html"><![CDATA[<p>常用命令<code>hexo clean, hexo g, hexo g</code>。上传相册需要把相册保存到source/photos/ins目录下，然后在hexo根目录下运行python encode_jpg.py，实现图片压缩、缩略图生成。每次生成新的博客，在部署到github后需要运行<code>node comment.js</code>来批量化开启gitalk评论区。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用命令&lt;code&gt;hexo clean, hexo g, hexo g&lt;/code&gt;。上传相册需要把相册保存到source/photos/ins目录下，然后在hexo根目录下运行python encode_jpg.py，实现图片压缩、缩略图生成。每次生成新的博客，在部署到github后需要运行&lt;code&gt;node comment.js&lt;/code&gt;来批量化开启gitalk评论区。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://xkwang.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
