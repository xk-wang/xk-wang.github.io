<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XK</title>
  <icon>https://www.gravatar.com/avatar/4a844ada4cba7aee005f4edded2b07b9</icon>
  <subtitle>为者常成，行者常至</subtitle>
  <link href="http://xkwang.cn/atom.xml" rel="self"/>
  
  <link href="http://xkwang.cn/"/>
  <updated>2021-04-06T15:22:47.538Z</updated>
  <id>http://xkwang.cn/</id>
  
  <author>
    <name>xkwang</name>
    <email>xk_wang@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux查看内核版本和发行版版本</title>
    <link href="http://xkwang.cn/post/f5394aaf.html"/>
    <id>http://xkwang.cn/post/f5394aaf.html</id>
    <published>2021-03-20T02:49:34.000Z</published>
    <updated>2021-04-06T15:22:47.538Z</updated>
    
    <content type="html"><![CDATA[<p>查看内核版本uname -a; 查看发新版版本cat /etc/os-release。</p><a id="more"></a><p>查看linux内核版本</p><ol><li>uname -a 可以看出系统是2017年10月20日安装的 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Linux</span> master <span class="number">3</span>.<span class="number">10</span>.<span class="number">0</span>-<span class="number">693</span>.<span class="number">5</span>.<span class="number">2</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span> #<span class="number">1</span> SMP Fri Oct <span class="number">20</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">50</span> UTC <span class="number">2017</span> x<span class="number">86</span>_<span class="number">64</span> x<span class="number">86</span>_<span class="number">64</span> x<span class="number">86</span>_<span class="number">64</span> GNU/Linux</span><br></pre></td></tr></table></figure></li><li>cat /proc/version 这个命令还会给出编译工具信息 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">Linux</span> version <span class="number">3</span>.<span class="number">10</span>.<span class="number">0</span>-<span class="number">693</span>.<span class="number">5</span>.<span class="number">2</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span> (builder@kbuilder.dev.centos.org) (gcc version <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span> <span class="number">20150623</span> (Red Hat <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">16</span>) (GCC) ) #<span class="number">1</span> SMP Fri Oct <span class="number">20</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">50</span> UTC <span class="number">2017</span></span><br></pre></td></tr></table></figure>查看linux发行版信息 CentOS和Ubuntu通用</li></ol><p>cat /etc/os-release</p><ol><li>CentOS结果<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NAME</span>=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line"><span class="attr">VERSION</span>=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line"><span class="attr">ID</span>=<span class="string">&quot;centos&quot;</span></span><br><span class="line"><span class="attr">ID_LIKE</span>=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line"><span class="attr">VERSION_ID</span>=<span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="attr">PRETTY_NAME</span>=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line"><span class="attr">ANSI_COLOR</span>=<span class="string">&quot;0;31&quot;</span></span><br><span class="line"><span class="attr">CPE_NAME</span>=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line"><span class="attr">HOME_URL</span>=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line"><span class="attr">BUG_REPORT_URL</span>=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CENTOS_MANTISBT_PROJECT</span>=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line"><span class="attr">CENTOS_MANTISBT_PROJECT_VERSION</span>=<span class="string">&quot;7&quot;</span></span><br><span class="line"><span class="attr">REDHAT_SUPPORT_PRODUCT</span>=<span class="string">&quot;centos&quot;</span></span><br><span class="line"><span class="attr">REDHAT_SUPPORT_PRODUCT_VERSION</span>=<span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure></li><li>Ubuntu结果<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="attr">NAME</span>=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">   <span class="attr">VERSION</span>=<span class="string">&quot;20.04.1 LTS (Focal Fossa)&quot;</span></span><br><span class="line"><span class="attr">ID</span>=ubuntu</span><br><span class="line">   <span class="attr">ID_LIKE</span>=debian</span><br><span class="line">   <span class="attr">PRETTY_NAME</span>=<span class="string">&quot;Ubuntu 20.04.1 LTS&quot;</span></span><br><span class="line">   <span class="attr">VERSION_ID</span>=<span class="string">&quot;20.04&quot;</span></span><br><span class="line">   <span class="attr">HOME_URL</span>=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">   <span class="attr">SUPPORT_URL</span>=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">   <span class="attr">BUG_REPORT_URL</span>=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">   <span class="attr">PRIVACY_POLICY_URL</span>=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">   <span class="attr">VERSION_CODENAME</span>=focal</span><br><span class="line">   <span class="attr">UBUNTU_CODENAME</span>=focal</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;查看内核版本uname -a; 查看发新版版本cat /etc/os-release。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://xkwang.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++源码编译过程</title>
    <link href="http://xkwang.cn/post/34037422.html"/>
    <id>http://xkwang.cn/post/34037422.html</id>
    <published>2021-03-07T04:40:02.000Z</published>
    <updated>2021-03-07T04:58:11.888Z</updated>
    
    <content type="html"><![CDATA[<p>C++源码编译需要4个步骤 预编译，编译，汇编，链接。</p><a id="more"></a><p>C/C++编译的过程分为<strong>预编译、编译、汇编、链接</strong>四个部分，分别由与编译器，编译器，汇编器和链接器完成。其中各个步骤使用gcc/g++命令和每个步骤的任务如下所示：</p><ol><li>预编译部分完整宏展开，将相关的头文件和宏定义进行展开，头文件以一种类似拷贝的方式包含到被调用的文件中，但又不完全等同于拷贝，宏定义直接进行替换；</li><li>编译部分将C代码转换到汇编代码；</li><li>汇编部分将汇编代码转成目标代码，也就是机器代码；</li><li>最后链接器将各个编译好的文件，以及库文件进行链接，得到可执行文件。</li></ol><p>每个步骤的编译器指令：</p><ol><li>预编译g++ -E file.cpp -o file1</li><li>编译g++ -S file1 -o file2</li><li>汇编g++ -c file2 -o file3</li><li>链接g++ file3 -o file4</li></ol><p>简单的记忆方法，键盘上的ESc字母，就是前两个字母需要大写，最后链接器没有参数。</p><ol><li>编译不需要头文件参与，头文件只是让编译器知道有这样一些成员的存在；</li><li>当执行第n步的转换时，如果没有进行前面步骤的转换，则编译器将自动完成；</li><li>C++采取的时分离式编译过程，只有到最后链接的一步骤才把所有的源文件关联到一起。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++源码编译需要4个步骤 预编译，编译，汇编，链接。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vmware中的网络连接方式</title>
    <link href="http://xkwang.cn/post/89432efe.html"/>
    <id>http://xkwang.cn/post/89432efe.html</id>
    <published>2021-03-07T04:37:51.000Z</published>
    <updated>2021-03-07T04:38:58.111Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="default" scheme="http://xkwang.cn/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>linux中scp使用</title>
    <link href="http://xkwang.cn/post/221fa5a3.html"/>
    <id>http://xkwang.cn/post/221fa5a3.html</id>
    <published>2021-03-07T04:37:38.000Z</published>
    <updated>2021-03-07T04:38:58.110Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="default" scheme="http://xkwang.cn/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>linux中的rename</title>
    <link href="http://xkwang.cn/post/ec323bcb.html"/>
    <id>http://xkwang.cn/post/ec323bcb.html</id>
    <published>2021-03-07T04:36:54.000Z</published>
    <updated>2021-03-07T04:38:58.109Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="default" scheme="http://xkwang.cn/tags/default/"/>
    
  </entry>
  
  <entry>
    <title>C++中的模板编程</title>
    <link href="http://xkwang.cn/post/b829f22b.html"/>
    <id>http://xkwang.cn/post/b829f22b.html</id>
    <published>2021-03-07T04:00:41.000Z</published>
    <updated>2021-03-20T01:25:01.539Z</updated>
    
    <content type="html"><![CDATA[<p>cp是中模板编程是泛型技术实现的基础，包含函数模板和类模板。</p><a id="more"></a><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><ol><li><p>使用template <typename T>或者template <class T>进行类型声明。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1.0</span>,<span class="number">2.0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数模板使用时可以不指定类型，由编译器自动推导，也可以显示指定。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一下两种写法均可</span></span><br><span class="line">Max&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line">Max(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></li><li><p>函数模板如果让编译器自动推断类型，必须进行严格类型匹配，不能像普通函数一样进行自动类型转换。如果想要进行自动类型转换，需要显示指定类型。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max(<span class="number">1.0</span>, <span class="number">2</span>); <span class="comment">// 错误，不能自动把2转换成double或者float</span></span><br><span class="line">Max&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>在函数模板和普通函数都能匹配时，优选选择普通函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;template function!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ordinary function!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;Max(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ordinary <span class="keyword">function</span>!</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 等价template&lt;class NameType, class AgeType&gt;</span></span><br><span class="line"><span class="comment">// 需要使用多少个类型就用多少类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(NameType name, AgeType age)</span><br><span class="line">  &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;P1(<span class="string">&quot;ali&quot;</span>, <span class="number">90</span>);</span><br><span class="line">  P1.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板派生</p><ol><li>类模板派生普通类，需要指定具体泛型类别；</li><li>类模板派生模板类，继续使用template。</li></ol><h4 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h4><ol><li>类模板不存在自动推导，必须要显示指定类型，因为编译器需要知道占据内存大小；</li><li>类模板可以使用默认参数； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的AgeType默认类型为int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType=<span class="keyword">int</span>&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(NameType name, AgeType age)</span><br><span class="line">  &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。"><a href="#模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。" class="headerlink" title="模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。"></a>模板存在两次编译过程，第二次是直接编译模板本身，第二次是根据调用情况将模板翻译成具体数据类型的函数。</h4>由于模板需要两次编译和C++的分离式编译特点，模板类的声明和实现需要写在一个文件中，否则会出现链接错误，这样的文件后缀为hcpp。</li></ol><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>为了防止头文件重复包含，C/C++中使用两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// C/C++语言支持，使用一定没问题</span><br><span class="line"><span class="comment">#ifndefine _TEST</span></span><br><span class="line"><span class="comment">#define _TEST</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 编译器支持，老式编译器不支持</span><br><span class="line"><span class="comment">#pragma once</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;cp是中模板编程是泛型技术实现的基础，包含函数模板和类模板。&lt;/p&gt;</summary>
    
    
    
    
    <category term="STL" scheme="http://xkwang.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++类的基本成员函数</title>
    <link href="http://xkwang.cn/post/1705cf83.html"/>
    <id>http://xkwang.cn/post/1705cf83.html</id>
    <published>2021-03-07T03:56:29.000Z</published>
    <updated>2021-03-07T03:57:09.768Z</updated>
    
    <content type="html"><![CDATA[<p>等待完善</p><a id="more"></a><p>cpp有哪些类方法如果没有定义编译器会自动生成呢？如果没有定义,构造函数，析构函数，拷贝构造函数，赋值运算符重载都会由编译器自动构造，而移动复制构造不会。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;等待完善&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常量运行池</title>
    <link href="http://xkwang.cn/post/53afdded.html"/>
    <id>http://xkwang.cn/post/53afdded.html</id>
    <published>2021-03-07T02:50:07.000Z</published>
    <updated>2021-03-07T02:51:04.291Z</updated>
    
    <content type="html"><![CDATA[<p>等待完善</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;等待完善&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的指针</title>
    <link href="http://xkwang.cn/post/762f2a61.html"/>
    <id>http://xkwang.cn/post/762f2a61.html</id>
    <published>2021-03-07T02:21:20.000Z</published>
    <updated>2021-03-07T02:40:34.800Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++中指针是个非常底层的概念，能够进行的操作（包括破坏力）超乎想象。</p><a id="more"></a><p>问题来源于牛客网的一道题目</p><p>下面代码输出的是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> *ptr = (<span class="keyword">int</span>*)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(ptr<span class="number">-2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目做的很犹豫，这是到现在第一次看到一个对二维数组求地址的操作，不知道表达啥意思，所以开始做错了。</p><p>可以从升维的角度来看待指针问题，每次取第一个地址，指针的视角就更高了一层。比如，对int取地址，看到了一个int数据的内存，一个一维int数组的地址，看到的是真个数组的内存空间，而一个二维数组的地址，则看到了整个二维数组的内存空间。</p><p>因此，a相当于一个行指针，能够看到二维数组的每一行，那么&amp;a便能看到所有行的空间也就是10个int数据的内存，因此&amp;a+1指针向后移动10个int数据的空间，也即数字10的后面，然后进行类型强制转换将int***转换成int*，因此后续ptr只能看到int内存的大小，于是ptr-2指向9，最终的值也便是9.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C/C++中指针是个非常底层的概念，能够进行的操作（包括破坏力）超乎想象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中文件输入输出</title>
    <link href="http://xkwang.cn/post/7217e645.html"/>
    <id>http://xkwang.cn/post/7217e645.html</id>
    <published>2021-03-06T12:25:54.000Z</published>
    <updated>2021-03-07T00:46:08.779Z</updated>
    
    <content type="html"><![CDATA[<p>C++中文件输入输出主要包含文件输入输出流和文件读写模式的问题。</p><a id="more"></a><h3 id="C-中文件的读写模式"><a href="#C-中文件的读写模式" class="headerlink" title="C++中文件的读写模式"></a>C++中文件的读写模式</h3><p>C++ primer中介绍了C++文件读写的6中模式，但是这些模式具体的作用说的不是很明了，特别是trunc模式被翻译为“截断模式”实在是没理解是啥意思，这里进行总结。</p><table><thead><tr><th>文件模式</th><th>作用</th><th>使用对象</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开</td><td>ifstream, fstream</td></tr><tr><td>ios::out</td><td>为写文件而打开文件，会删除源文件内容，相当于trunc | out</td><td>ofstream, fstream</td></tr><tr><td>ios::app</td><td>以追加方式写文件</td><td>ofstream, fstream</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td><td>ofstream, fstream</td></tr><tr><td>ios::ate</td><td>初始位置在文件末尾</td><td>任意</td></tr><tr><td>ios::binary</td><td>二进制方式读写文件</td><td>任意</td></tr></tbody></table><p>C++中文件输入输出流都有设置默认的模式，ifstream的默认模式是in，ofstream的默认模式是out，fstream的默认模式是in和out。</p><p>如果想要ofstream不覆盖原本文件的内容，要么设置ate模式，要么设置in模式（ofstream可以设置in模式，ifstream也可以设置out模式，但具体作用还有待深究，这里先不纠结）。</p><h3 id="C-中文件输入输出流"><a href="#C-中文件输入输出流" class="headerlink" title="C++中文件输入输出流"></a>C++中文件输入输出流</h3><p>C++中使用流的过程：首先在内存中定义一个流对象，然后将这个流对象与硬盘中的文件关联起来，通过这个流对象操作文件。</p><p>三个基本流fstream，ifstream，ofstream。fstream继承自iostream。<br>流的方法：fstream.open显示地打开文件（创建流对象和文件的关联），fstream.close关闭流对象，fstream.is_open成功打开并且没有关闭返回true否则false。</p><p>流的打开方式：</p><ol><li>构造对象时直接传入string对象或者C风格字符串来代表文件路径；</li><li>先构造对象，先创建文件流对象，后续调用open函数。</li></ol><p>检查流对象是否成功打开是个好习惯，直接用if语句判断流对象即可。</p><h4 id="读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。"><a href="#读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。" class="headerlink" title="读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。"></a>读取文本文件，要想读取文件必须把文件保存到内存，便需要使用string对象来接收文本。</h4><ol><li>读取整个文件，首先使用ate模式将输入位置指示器移动到文件结尾，再使用tellg获取输入指示器的位置，得到需要构建的内存大小。再使用seekg(0)把输入指示器移动到文件开头，以便对文件进行读取。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p, <span class="built_in">std</span>::ios::ate)</span></span>; <span class="comment">// 先将输入指示器移动到文件结尾</span></span><br><span class="line">    <span class="keyword">if</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> size = input.tellg(); <span class="comment">// 获取输入指示器的位置</span></span><br><span class="line">      input.seekg(<span class="number">0</span>); <span class="comment">// 将输入指示器移动到文件开头</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(size, <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(input.read(&amp;str[<span class="number">0</span>], size)) <span class="comment">// 从string对象中获取string字符串的初地址</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>逐行读取文件，使用getline函数即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">      getline(input, str);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>getline会去掉原始文本中的换行符，因此此处加上了endl。结果如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">I am wangxianke from hust</span><br><span class="line">I am glad to hear from you.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是为什么会多出来一个空行呢？我的文件里面没有空行，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">I am wangxianke from hust</span><br><span class="line">I am glad to hear from you.</span><br></pre></td></tr></table></figure><p>原因是上述循环代码写的有问题，改为如下就正常。原本代码是在while里面判断input条件，相当于是判断input.eof()，但是当读取到文本最后一行时input.eof返回true，于是还会继续读取一行，但是会读取失败，于是最后就多了个endl换行了。正确的写法不是判断当前是否是eof，而是当前按能否读取成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getline(input, str))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意如果使用fstream的&gt;&gt;重载那么&gt;&gt;遇到空格便会停止一次读取，最终不是读取一行而是读取每个单词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(input &gt;&gt; str)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">wangxianke</span><br><span class="line">from</span><br><span class="line">hust</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">glad</span><br><span class="line">to</span><br><span class="line">hear</span><br><span class="line">from</span><br><span class="line">you.</span><br></pre></td></tr></table></figure><h4 id="读写二进制文件，使用read和write函数"><a href="#读写二进制文件，使用read和write函数" class="headerlink" title="读写二进制文件，使用read和write函数"></a>读写二进制文件，使用read和write函数</h4><p>写文件就没有必要去区分逐行写还是整个写了，只要流没有关闭，便能不停的写入。</p><p>两种写文件方式，使用二进制写文件或者从文本输出，C++将自动完成编码和解码工作。<br>这里使用二进制方式写入文件和读取文件，便能直接将float和int数据写入文件。<br>当然直接打开Test.b这个文本文件会乱码，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^_&lt;85&gt;&lt;EB&gt;Q&lt;B8&gt;^^       @123abc</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> filename = <span class="string">&quot;Test.b&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">ostrm</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    ostrm.write(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d), <span class="keyword">sizeof</span> d); <span class="comment">// 二进制输出</span></span><br><span class="line">    ostrm &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;abc&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                      <span class="comment">// 文本输出</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 回读</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::ifstream <span class="title">istrm</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  istrm.read(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d), <span class="keyword">sizeof</span> d);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">  istrm &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; read back: &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> back: 3.14 123 abc</span><br></pre></td></tr></table></figure><p>需要使用iostream&amp;的地方可以传入fstream，这样只需要少量修改便能将标准输入输出改成文件输入输出。</p><h4 id="文件流的关闭"><a href="#文件流的关闭" class="headerlink" title="文件流的关闭"></a>文件流的关闭</h4><p>一般使用完流对象之后需要及时进行流的关闭。文件流对象会自动的创建和销毁，并且在销毁前会调用close函数。如下函数所示，每次循环都会重新构建文件流对象，在离开每次循环作用域时流对象会被自动销毁，并在销毁前调用构造函数，因此此处不需要手动关闭流对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; ++p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span><span class="params">(*p)</span></span>; <span class="comment">// 得到每个字符串首地址</span></span><br><span class="line">    <span class="keyword">if</span>(input)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 或者从char*构建string对象以符合cpp风格</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(*p) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">./test file/test1.txt file/test2.txt file/test3.txt file/test5.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中文件输入输出主要包含文件输入输出流和文件读写模式的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="http://xkwang.cn/post/c39717db.html"/>
    <id>http://xkwang.cn/post/c39717db.html</id>
    <published>2021-02-22T00:24:14.000Z</published>
    <updated>2021-02-25T02:16:14.330Z</updated>
    
    <content type="html"><![CDATA[<p>static变量保存在全局数据区，static函数保存在代码区。static起到隐藏、类共享成员作用。</p><a id="more"></a><h4 id="static数据特点"><a href="#static数据特点" class="headerlink" title="static数据特点"></a>static数据特点</h4><ul><li>static变量只被初始化一次，默认初始化为0；</li><li>static变量保存在全局数据区，全局变量作用域具有全局可见性，static全局变量作用域具有文件内可见性，生存周期贯穿整个程序生命周期；static局部变量作用域具有局部可见性，生存周期也是贯穿整个程序生命周期，但是出了局部作用域便不可见；</li><li>static函数保存在代码区。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 静态变量放在全局数据区</span></span><br><span class="line">    <span class="comment">// 静态函数放在代牧区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x408024</span></span><br><span class="line">             &lt;&lt;&amp;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x408028</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x401410 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x40143e 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>  <span class="comment">// 0x40146c 占2e</span></span><br><span class="line">             &lt;&lt;(<span class="keyword">void</span>*)&amp;f4&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x40149a 占2e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类外static起到隐藏作用"><a href="#类外static起到隐藏作用" class="headerlink" title="类外static起到隐藏作用"></a>类外static起到隐藏作用</h4></li><li>分离式编译中隐藏其它文件的全局变量</li><li>分离式编译中隐藏其它文件的全局函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello world 2&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    f1(); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: conflicting specifiers in declaration of &#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="comment">// error: conflicting specifiers in declaration of &#x27;f2&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>至于隐藏的原理，后续在补充，还没看到相关博客内容</li></ul><h4 id="类内static成员"><a href="#类内static成员" class="headerlink" title="类内static成员"></a>类内static成员</h4><ul><li>类的静态数据成员，静态函数成员属于整个类而非对象，没有隐式的指针，因此静态成员函数不能声明为const，只能访问静态数据成员和静态函数成员；</li><li>静态成员函数不能为虚函数（虚函数存在this指针动态绑定过程）；</li><li>静态成员存储空间在类的存储空间外；</li><li>静态成员在类外初始化，在类内声明。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;static变量保存在全局数据区，static函数保存在代码区。static起到隐藏、类共享成员作用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中char的地址</title>
    <link href="http://xkwang.cn/post/a19b496f.html"/>
    <id>http://xkwang.cn/post/a19b496f.html</id>
    <published>2021-02-21T12:44:33.000Z</published>
    <updated>2021-02-23T05:49:53.332Z</updated>
    
    <content type="html"><![CDATA[<p>打印char a地址需要使用<code>std::cout&lt;&lt;(void*)&amp;a</code>进行，因为&amp;a类型是char*，对于char* std::cout会认为是字符串起始地址，因此会输出从起始地址到’\0’的字符串。而char的存储空间无’\0’字符，因此<code>std::cout&lt;&lt;&amp;a</code>会访问到非法内存，输出乱码。如需打印地址需要进行类型转换。</p><a id="more"></a><p>对于函数指针的打印也需要先类型转换成void*，因为函数指针没有对&lt;&lt;运算符重载，会导致函数指针自动转换成bool类型，从而打印1。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打印char a地址需要使用&lt;code&gt;std::cout&amp;lt;&amp;lt;(void*)&amp;amp;a&lt;/code&gt;进行，因为&amp;amp;a类型是char*，对于char* std::cout会认为是字符串起始地址，因此会输出从起始地址到’\0’的字符串。而char的存储空间无’\0’字符，因此&lt;code&gt;std::cout&amp;lt;&amp;lt;&amp;amp;a&lt;/code&gt;会访问到非法内存，输出乱码。如需打印地址需要进行类型转换。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++四种类型转换的区别</title>
    <link href="http://xkwang.cn/post/158a3f9d.html"/>
    <id>http://xkwang.cn/post/158a3f9d.html</id>
    <published>2021-02-21T12:34:26.000Z</published>
    <updated>2021-03-01T14:38:45.096Z</updated>
    
    <content type="html"><![CDATA[<p>C++四种类型转换，static_cast编译时进行，下行转换不安全，dynamic_cast运行时进行，下行转换安全，const_cast可用于去除const，谨慎使用，reinterpret_cast从底层二进制进行转换，无所不能，不到万不得以不能用。</p><a id="more"></a><h4 id="四种类型转换的使用"><a href="#四种类型转换的使用" class="headerlink" title="四种类型转换的使用"></a>四种类型转换的使用</h4><p><b>static_cast</b><br>下行转换：基类 –&gt; 派生类转换<br>上行转换：派生类–&gt;基类转换<br>编译时进行类型转换<br>应用</p><ul><li>上行转换安全，下行转换不安全，可能造成非法内存访问；</li><li>一般常见的其它类型转换</li></ul><p><b>dynamic_cast</b><br>运行时进行类型转换，被转换对象需要有虚函数进行运行时类型判别。<br>相比较于static_cast，dynamic_cast的下行转换安全，如果转换失败返回空指针。</p><p><b>const_cast</b><br>const_cast可以进行 <b>const对象–&gt;非const类型转换</b>  和 <b>非const类型转换–&gt;const类型</b>转换两种类型。唯一一个可以对const对象进行使用的转换，使用需要谨慎，防止修改了const对象。典型应用场景是底层const类型的函数重载。</p><p>一个危险的使用方式，通过const_cast之后改变了通过b改变了a原始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b=a;</span><br><span class="line"><span class="keyword">auto</span> &amp;c=<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(b);<span class="comment">//必须要指定引用，详情看auto使用</span></span><br><span class="line">c=<span class="number">1</span>; <span class="comment">//a的值变为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b=a;</span><br><span class="line"><span class="keyword">auto</span> &amp;c=<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(b);</span><br><span class="line">c=<span class="number">1</span>; <span class="comment">//a的值还是0</span></span><br></pre></td></tr></table></figure><br>一个正常的使用方式，用作const底层重载的参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;const function&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> s1.size()&lt;s2.size()?s1: s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not const function&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> s1.size()&lt;s2.size()?s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;result1=shorterString(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello world&quot;</span>); <span class="comment">// 调用const function</span></span><br><span class="line">  string s1(&quot;hello&quot;), s2(&quot;hello world&quot;);</span><br><span class="line">  <span class="keyword">auto</span> &amp;result2=shorterString(s1, s2); <span class="comment">// 调用not const function</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;result3=shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2)); <span class="comment">//调用const function</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;result4=<span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(result3); <span class="comment">//恢复可变性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><b>reinterpret_cast</b><br>最不安全，从底层二进制进行类型转换，依赖于平台，十分危险不能使用，可以进行任意类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> *b=<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++四种类型转换，static_cast编译时进行，下行转换不安全，dynamic_cast运行时进行，下行转换安全，const_cast可用于去除const，谨慎使用，reinterpret_cast从底层二进制进行转换，无所不能，不到万不得以不能用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类内存字节对齐</title>
    <link href="http://xkwang.cn/post/30f3ce8a.html"/>
    <id>http://xkwang.cn/post/30f3ce8a.html</id>
    <published>2021-02-21T09:56:17.000Z</published>
    <updated>2021-02-22T10:00:06.856Z</updated>
    
    <content type="html"><![CDATA[<p>内存对齐的两个基本原则是首地址偏移量需要是min（对齐单位，成员字节数）的倍数，总字节数需要是对齐单位倍数。</p><a id="more"></a><p>本文内容参考 <a href="https://zhuanlan.zhihu.com/p/30007037">https://zhuanlan.zhihu.com/p/30007037</a><br>版权归<a href="https://www.zhihu.com/people/qinlibo_nlp">忆臻</a>所有。</p><h3 id="内存对齐的必要性"><a href="#内存对齐的必要性" class="headerlink" title="内存对齐的必要性"></a>内存对齐的必要性</h3><p>虽然内存以字节为单位进行保存，但处理器寄存器一次性读取数据可能按照双字节、4字节、8字节等进行读取。32位系统的存取粒度是4字节，64位系统的存取力度是8字节。考虑32位系统下从地址1开始存放一个int，那么处理器需要读取两次数据，并且经过两次移位，一次拼接完成int的读取，这些导致数据读取速度的下降。内存对齐牺牲一定的存储空间，来换取更快的内存访问速度。</p><h3 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h3><h4 id="对齐模数"><a href="#对齐模数" class="headerlink" title="对齐模数"></a>对齐模数</h4><ul><li>对齐模数：每个平台下的不同编译器都有自己默认的对齐模数，win 64 gcc32的默认对齐模数是8，centos64 gcc64默认对齐模数也是8。可以通过预编译命令#pragma pack(n)进行修改；</li><li>对齐单位：min（对齐模数，max（类中数据成员字节数））</li></ul><h4 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h4><ol><li>第一个类成员首地址offset为0，之后每个成员首地址offset是<strong>min（对齐单位，该成员字节数）的整数倍</strong>，如有需要编译器会进行字节填充；</li><li>类总字节数是<strong>对齐单位</strong>整数倍，如有需要编译器会进行字节填充。</li></ol><p>例子（win10 gcc32 环境，默认对齐模数是8）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="keyword">char</span> z; <span class="comment">// 类B中占据8 Bytes,作为类C成员占据4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B b; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1c</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 24 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32 Bytes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B的内存分布 24字节</p><p>| 虚表指针4字节 | x 4字节 | y 8字节 | z 1字节 <strong>填充7字节</strong> |</p><p>C的内存分布 32字节</p><p>| C的虚表指针4字节 | B的虚表指针4字节 | B::x 4字节 <strong>填充4字节</strong> | B::y 8字节 | B::z 1字节 <strong>填充7字节</strong> |</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内存对齐的两个基本原则是首地址偏移量需要是min（对齐单位，成员字节数）的倍数，总字节数需要是对齐单位倍数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++空白基类最优化</title>
    <link href="http://xkwang.cn/post/7f1322f0.html"/>
    <id>http://xkwang.cn/post/7f1322f0.html</id>
    <published>2021-02-21T09:26:04.000Z</published>
    <updated>2021-02-24T05:36:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>空白基类最优化（EBO empty base optimization 或 EBCO empty base class optimization）空类作为类成员是按照类内字节对齐方式占据内存，作为继承基类时在子类中占据字节被优化为0。</p><a id="more"></a><p>EBCO参考<a href="https://en.cppreference.com/w/cpp/language/ebo%E3%80%82">https://en.cppreference.com/w/cpp/language/ebo。</a></p><ul><li>mingw32环境下的EBO  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization applies</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span>&#125;; <span class="comment">// empty class 1 Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base &#123; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>如果空基类也是第一个非静态数据成员的类型或类型的基类，则禁止进行空基优化，因为同一类型的两个基子对象需要在<strong>最派生类型</strong>的对象表示中具有不同的地址。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization does not apply,</span></span><br><span class="line"><span class="comment">// base occupies 1 byte, Base member occupies 1 byte</span></span><br><span class="line"><span class="comment">// followed by 2 bytes of padding to satisfy int alignment requirements</span></span><br><span class="line"><span class="comment">// | Base 1 Byte | Base 1 Byte | 2 Bytes | i 4 Bytes |</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base &#123; <span class="comment">// 8 Bytes</span></span><br><span class="line">    Base c; <span class="comment">// Base, occupies 1 byte, followed by padding for i</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty base optimization does not apply,</span></span><br><span class="line"><span class="comment">// base takes up at least 1 byte plus the padding</span></span><br><span class="line"><span class="comment">// to satisfy alignment requirement of the first member (whose</span></span><br><span class="line"><span class="comment">// alignment is the same as int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// | Base 1 Byte | 3 Bytes | c 4 Bytes | i 4 Bytes |</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived3</span> :</span> Base &#123; <span class="comment">// 12 Bytes</span></span><br><span class="line">    Derived1 c; <span class="comment">// derived from Base, occupies sizeof(int) bytes</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>多继承，继承链中只要满足<strong>第一个非静态数据成员的类型或类型的基类不是空基类</strong>，照样进行空基优化。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass2</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> EmptyClass1&#123; <span class="comment">// 4 Bytes</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> EmptyClass1, <span class="keyword">public</span> EmptyClass2&#123; <span class="comment">// 4 Bytes</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived3</span>:</span> <span class="keyword">public</span> Derived1&#123; <span class="comment">// 8 Bytes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived4</span>:</span> <span class="keyword">public</span> Derived2&#123; <span class="comment">// 8 Bytes</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;空白基类最优化（EBO empty base optimization 或 EBCO empty base class optimization）空类作为类成员是按照类内字节对齐方式占据内存，作为继承基类时在子类中占据字节被优化为0。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的虚函数</title>
    <link href="http://xkwang.cn/post/fa71210a.html"/>
    <id>http://xkwang.cn/post/fa71210a.html</id>
    <published>2021-02-21T08:02:12.000Z</published>
    <updated>2021-03-07T02:43:20.638Z</updated>
    
    <content type="html"><![CDATA[<p>关于C++中的虚函数，两篇博客讲的很清楚，尤其是第一篇。<br><a href="https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA">https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA</a><br><a href="https://juejin.cn/post/6844903666667749389">https://juejin.cn/post/6844903666667749389</a><br>本文主要关注如何通过对象地址去调用虚函数。</p><a id="more"></a><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::g&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::h&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Fun pFun=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span>*)(&amp;b)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b)+<span class="number">1</span>));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b)+<span class="number">2</span>));</span><br><span class="line">  pFun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0x7ffe5355fb78<br>Base::f<br>Base::g<br>Base::h<br>其中a=（long*)(&amp;b)是虚表地址，long*(*a)是第一个虚函数地址。之所以需要转换为long*，是因为C++64位环境中指针占据8字节（同long，long*），这样后续的+1便能明确是将指针移动8字节，得到下一个虚函数的地址。</p><p>但是还有个疑问，上述写法(long*)*(long*)(&amp;b)是第一个虚函数地址，+1后得到第二个虚函数地址有点奇怪，因为第一个虚函数的代码占据代码区空间不一定是8字节，为什么加1就是第二个虚函数地址呢？相反，应该说虚表的第二个元素存储第二个虚函数地址，按道理应该按照下面的写，但是下面的写法是错误的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::f&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::g&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Base::h&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Base b;</span><br><span class="line">  Fun pFun=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;(<span class="keyword">long</span>*)(&amp;b)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  pFun=(Fun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)(&amp;b));</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*(<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)(&amp;b)+<span class="number">1</span>);</span><br><span class="line">  pFun();</span><br><span class="line">  pFun=(Fun)*(<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)(&amp;b)+<span class="number">2</span>);</span><br><span class="line">  pFun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>0x7ffd0e186818<br>Base::f<br>Segmentation fault (core dumped)</p><p>仔细思考下，自己想错了，这个要仔细画图去体会</p><div style="text-align: center"><img src="/assets/blog/fa71210a/vtable.jpg" margin="0 auto" width="50%" height="50%"/></div><p>从图中可以看出，long*(&amp;b)是对象成员的首地址，也就是虚表指针的首地址，*(long*)(&amp;b)得到对象第一个成员的值，也就是虚表的地址，还是一样，进行类型强转，因此为(long*)*(long*)(&amp;b)。至此，虚表的首地址得到，为p=(long*)*(long*)(&amp;b)，那么+1，+2，+3为虚表后续元素的地址，*(p+n)便得到第n+1个虚函数的地址，为了进行函数调用，进行类型强转，变为函数指针，因此为(Fun)*(p+n)，便得到代码1的结果。</p><p>代码2中(long*)(&amp;b)+n得到的是第n+1个数据成员地址，而Base对象只有一个虚表指针成员，因此后续代码造成了非法内存访问，于是出现段错误。</p><p>还有个问题是如果编程时明确指定了派生类调用基类的同名函数，如p-&gt;A::func那么func的类型在编译时便能确定，调用的就是基类的函数，也就不存在动态绑定的问题了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于C++中的虚函数，两篇博客讲的很清楚，尤其是第一篇。&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA&quot;&gt;https://mp.weixin.qq.com/s/ZvtEL-d0-2a2QXoAGXTCCA&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/6844903666667749389&quot;&gt;https://juejin.cn/post/6844903666667749389&lt;/a&gt;&lt;br&gt;本文主要关注如何通过对象地址去调用虚函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>decltype和auto的比较</title>
    <link href="http://xkwang.cn/post/e85c9ea6.html"/>
    <id>http://xkwang.cn/post/e85c9ea6.html</id>
    <published>2021-02-20T13:21:37.000Z</published>
    <updated>2021-03-03T14:49:51.979Z</updated>
    
    <content type="html"><![CDATA[<p>auto和decltype称为占位符，在编译时进行自动类型推断。</p><a id="more"></a><h4 id="auto使用的几点注意"><a href="#auto使用的几点注意" class="headerlink" title="auto使用的几点注意"></a>auto使用的几点注意</h4><ol><li>auto从给定初值中进行类型推断，使用auto的表达式同时完成定义和初始化；</li><li>auto支持一行语句定义多个变量，但需要类型相同。注意&amp;和*非基本数据类型； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a; <span class="comment">// 正确 auto类型推断为int</span></span><br><span class="line"><span class="keyword">auto</span> d=&amp;a; <span class="comment">// 正确，auto推断类型为int*</span></span><br><span class="line"><span class="keyword">auto</span> *d1=&amp;a; <span class="comment">// 正确，auto推断类型也是int*，auto推断可以看出很灵活</span></span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a, d=&amp;a; <span class="comment">// 错误 前两个auto推断为int,后面为int*</span></span><br><span class="line"><span class="keyword">auto</span> b=a, &amp;c=a, *d=&amp;a;<span class="comment">// 正确 auto全部推断为int </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> x=a, y=m, *z=&amp;m; <span class="comment">// x,y均int，但&amp;z是const int类型，error</span></span><br></pre></td></tr></table></figure></li><li>使用引用时参与初始化的是引用对象的值，而非引用对象本身； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">// b类型int而非const int &amp;</span></span><br></pre></td></tr></table></figure></li><li>auto一般会忽略顶层const，保留底层const。如果希望保留顶层const，需要自行在auto前添加const； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b=a; <span class="comment">// b int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> c=a; <span class="comment">// c是const int a，const属性自己添加。</span></span><br></pre></td></tr></table></figure></li><li>设置类型为auto引用或auto指针时，初始值中的顶层const属性得到保留。因为对const取引用或者取地址一定是底层const。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;b=a, *c=&amp;a; <span class="comment">// b为const int &amp;, c为const int *</span></span><br></pre></td></tr></table></figure>关于auto以下几条肯定成立：</li></ol><ul><li>不能用作函数参数。auto需要编译时确定类型，但是函数编译时不能进行形式结合，无法判定类型；</li><li>auto不能用作类的非静态成员，只有类的静态成员才具有初值（要么默认的0，要么类外初始化），类的普通成员编译时不能得到具体参数；</li><li><h4 id="decltype使用的几点注意"><a href="#decltype使用的几点注意" class="headerlink" title="decltype使用的几点注意"></a>decltype使用的几点注意</h4></li></ul><ol><li>decltype使用表达式的类型进行推断，并不实际计算表达式（也不调用函数）；</li><li>如果decltype使用的是变量，返回变量的类型，包含引用和顶层const；</li><li>如果decltype使用的表达式不是变量，返回表达式的结果对应类型； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b=a;</span><br><span class="line"><span class="keyword">decltype</span>(b) c; <span class="comment">// 类型int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(b+<span class="number">1</span>) d; <span class="comment">//类型int</span></span><br></pre></td></tr></table></figure></li><li>decltype内部如果使用括号结果一定是引用。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;auto和decltype称为占位符，在编译时进行自动类型推断。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>new和malloc的区别</title>
    <link href="http://xkwang.cn/post/c69e57ea.html"/>
    <id>http://xkwang.cn/post/c69e57ea.html</id>
    <published>2021-02-20T11:47:27.000Z</published>
    <updated>2021-03-03T23:40:23.224Z</updated>
    
    <content type="html"><![CDATA[<p>new和malloc的10点区别。本文内容参考<a href="https://www.cnblogs.com/QG-whz/p/5140930.html%E3%80%82">https://www.cnblogs.com/QG-whz/p/5140930.html。</a></p><a id="more"></a><ol><li>new是C++的关键字，需要编译器提供支持（当然都支持）；malloc是库函数，需要include&lt;malloc.h&gt;的头文件；</li><li>new是C++的运算符，支持重载，而malloc不支持；</li><li>new分配内存是在自由存储区，自由存储区是个抽象概念，详情参考<a href="8f50d358.html">C++的存储结构</a>。而malloc分配内存是在堆区；</li><li>new分配内存失败会返回bad_alloc异常，而mallc失败返回NULL；</li><li>new返回类型安全，是指向对象的指针，而malloc返回类型不安全，是一个(void*)指针，需要用户进行强制类型转换；</li><li>new会调用对象的构造函数，在内存空间中构造每个数据成员，而malloc不会调用构造函数，只是返回一个指向原始内存空间的指针，因此，OOP中不适合使用malloc。同理，delete会调用析构函数，而free不会；</li><li>new不需要显示确定每个对象的大小，编译器会自行计算，而malloc需要使用sizeof运算符显示指出；</li><li>new内部可以通过调用malloc实现，但是反过来不行；</li><li>malloc存在直观的重新分配内存方式realloc，new不存在直观的方式；</li><li>new抛出异常之前先去执行用户指定的错误处理函数，具体可以由用户控制，malloc只能返回NULL，无其它能做的事情。</li></ol><p>关于C++ free函数是如何判断内存空间的大小？<br>现代C++编译器在使用malloc分配内存时，将内存大小存放在分配内存前面的地址空间内，对于每个编译器其值固定。这样free是通过当前指针便能找到占用内存大小，从而确定free内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;new和malloc的10点区别。本文内容参考&lt;a href=&quot;https://www.cnblogs.com/QG-whz/p/5140930.html%E3%80%82&quot;&gt;https://www.cnblogs.com/QG-whz/p/5140930.html。&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的this指针</title>
    <link href="http://xkwang.cn/post/5082990a.html"/>
    <id>http://xkwang.cn/post/5082990a.html</id>
    <published>2021-02-20T09:16:53.000Z</published>
    <updated>2021-02-23T05:10:12.509Z</updated>
    
    <content type="html"><![CDATA[<p>C++中this指针是隐式的成员函数参数，类似python中的self，当访问数据成员或者函数成员时就会把对象的首地址赋值给this指针。this指针指向对象存储空间的首地址，也即第一个数据成员的首地址。因此，this指针不占据对象存储空间。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">location</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1,x2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff0f</span></span><br><span class="line">    b.location(); <span class="comment">// 0x61ff0f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b.x1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff08</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b.x2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0x61ff0c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中this指针是隐式的成员函数参数，类似python中的self，当访问数据成员或者函数成员时就会把对象的首地址赋值给this指针。this指针指向对象存储空间的首地址，也即第一个数据成员的首地址。因此，this指针不占据对象存储空间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类和对象的存储结构</title>
    <link href="http://xkwang.cn/post/8f50d358.html"/>
    <id>http://xkwang.cn/post/8f50d358.html</id>
    <published>2021-02-20T09:01:31.000Z</published>
    <updated>2021-02-25T00:38:45.717Z</updated>
    
    <content type="html"><![CDATA[<p>C++内存结构分为代码区，数据区和栈区。代码区存放编译的机器指令；数据区又分为堆区和全局数据区，其中堆区存放malloc出来的内存，全局数据区存放全局变量和静态变量；栈区存放自动变量，由编译器分配和释放。</p><a id="more"></a><h4 id="C-C-存储空间结构"><a href="#C-C-存储空间结构" class="headerlink" title="C/C++存储空间结构"></a>C/C++存储空间结构</h4><div style="text-align: center"><img src="/assets/blog/8f50d358/memory.jpg" margin="0 auto" width="50%" height="50%"/></div><blockquote><p>BSS: Block Started by Symbol，意为“以符号开始的块”。在C语言中还分：未初始化的全局变量和静态变量、已初始化的全局变量和静态变量。但是在C++中没有这个区分，他们共同占用同一块内存区。代码区和数据区内存数据从可执行文件中读取。</p></blockquote><ol><li>代码区：存放CPU执行的机器指令，代码区是可共享，并且是只读的；</li><li>数据区（全局/静态存储区）：存放已初始化的全局变量、静态变量（全局和局部）、常量数据；<ul><li>BBS区：存放未初始化的全局变量和静态变量；</li><li>GVAR区：存放已经初始化的全局变量和静态变量；</li></ul></li><li>栈区：由编译器自动分配释放，存放函数的参数值、返回值和局部变量，在程序运行过程中实时分配和释放，栈区由操作系统自动管理，无须程序员手动管理；</li><li>堆区：堆是由malloc()函数分配的内存块，使用free()函数来释放内存，堆的申请释放工作由程序员控制；</li><li><strong>自由存储区</strong>：由new分配的内存块都是自由存储区，是C++中才有的抽象概念。自由存储区不是一个具体的物理概念，对应的物理存储区可能是堆区，也可能是静态存储区，需要看不同编译器new的实现方式。</li></ol><p>new和malloc的区别参考<a href="c69e57ea.html">new和malloc区别</a>。</p><h3 id="基本数据类型占据内存大小"><a href="#基本数据类型占据内存大小" class="headerlink" title="基本数据类型占据内存大小"></a>基本数据类型占据内存大小</h3><p>32、64位编译器不同数据类型占据内存字节数如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">32位</th><th align="center">64位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center"><strong>long</strong></td><td align="center"><strong>4</strong></td><td align="center"><strong>8</strong></td></tr><tr><td align="center">long long</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center"><strong>指针</strong></td><td align="center"><strong>4</strong></td><td align="center"><strong>8</strong></td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr></tbody></table><h3 id="C-类和对象的存储"><a href="#C-类和对象的存储" class="headerlink" title="C++类和对象的存储"></a>C++类和对象的存储</h3><h4 id="C-类的构成："><a href="#C-类的构成：" class="headerlink" title="C++类的构成："></a>C++类的构成：</h4><p>数据成员：非静态的内置类型、对象类型，静态数据成员<br>函数成员：非虚函数，虚函数</p><blockquote><p>静态数据成员不与任何对象绑定，即不存在隐含的this指针，存放在堆区。静态成员函数不能声明成const（没有隐含的this指针），也不能在其内部使用this指针。</p></blockquote><ol><li>静态数据成员不占对象存储空间；</li><li>内置类型占据空间<a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8D%A0%E6%8D%AE%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F">如上</a>；</li><li>对象数据类型占据空间按照类内存对齐原则；</li><li>非虚函数不占内存；</li><li>虚函数存在虚函数指针占据内存。</li></ol><blockquote><p>类类型对齐原则是指在牺牲一定空间损失的情况下，换取内存读取次数的减少。详情参考<a href="30f3ce8a.html">C++类内字节对齐</a>。</p></blockquote><p>不保存函数成员的考虑：OOP编程其中一个目的就是代码重用，相同类不同对象的函数成员没有必要给每个对象保存，放置在公共区能节省内存。对象调用成员函数时通过域作用符和函数名便能寻址，然后把对象名传递给隐式的this指针便能分辨具体调用的是哪个对象。</p><p>虚函数通过虚表实现，包含虚函数的对象有一个指向虚表的指针，这个指针占据内存。</p><p>有关this的详细介绍参考<a href="5082990a.html">this指针</a>。<br>有关虚函数的详细介绍参考<a href="fa71210a.html">虚函数</a>。</p><h4 id="空白类对象占据1字节"><a href="#空白类对象占据1字节" class="headerlink" title="空白类对象占据1字节"></a>空白类对象占据1字节</h4><p>是为了不同实例之间的区分。空白类也能实例化，为了区分每个对象需要具有不同地址，因此至少得分配1字节内存。在继承时，如果基类是空白类，那么子类继承父类的那1个字节会被优化掉，变为0，成为空白基类最优化，参见<a href="7f1322f0.html">空白基类最优化</a>。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在win10 gcc32环境下类A占据内存8字节，类B占据内存24字节，类C占据内存32字节，类X占据内存8字节，如代码中注释。但在centos 64, gcc64环境下类A占据内存16字节，类B占据内存32字节，类C占据内存48字节，类X占据内存8字节。centos 64, gcc64环境的默认对齐系数也是8，但指针是8字节，造成了不同。</p><p>内存对齐会导致对象占据的空间比单个数据占据空间之和多，关于对象内存字节对齐，参考<a href="30f3ce8a.html">C++类内存对齐</a>。对象成员内存分布的先后顺序会影响内存对齐，虚表指针始终是对象内存空间的首元素，关于C++对象虚表的存储模型，参考<a href="fa71210a.html">C++虚函数</a>。排在第二的是从父类继承来的成员，最后是子类自己非继承、非虚表指针数据成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8) <span class="comment">//win10, mingw32的默认对齐模数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1a</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m; <span class="comment">// 这里只是声明, 没有定义, 需要类外定义(分配内存)</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> X::m; <span class="comment">// 类外进行静态成员定义 否则运行时错误undefined reference</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="keyword">char</span> z; <span class="comment">// 类B中是8 Bytes,作为类C成员是4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    B b; <span class="comment">// 4 Bytes</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1c</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 4 Bytes</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 24 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32 Bytes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(X)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8 Bytes 有无static int m无影响 m放在全局数据区</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;X::m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0 静态成员只进行一次初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++内存结构分为代码区，数据区和栈区。代码区存放编译的机器指令；数据区又分为堆区和全局数据区，其中堆区存放malloc出来的内存，全局数据区存放全局变量和静态变量；栈区存放自动变量，由编译器分配和释放。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中main函数参数</title>
    <link href="http://xkwang.cn/post/50d4ff1a.html"/>
    <id>http://xkwang.cn/post/50d4ff1a.html</id>
    <published>2021-02-20T08:40:09.000Z</published>
    <updated>2021-02-23T05:48:09.264Z</updated>
    
    <content type="html"><![CDATA[<p>C++ main函数带参数声明为<code>int main(int argc, char* argv[])</code>。第一个参数代表参数个数，第二个参数代表参数字符串数组。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//compile, g++ test.cpp -o test</span></span><br><span class="line"><span class="comment">//running, ./test 1 2.0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// sizeof(argv) will return the pointer size instead of array size like array!</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(argv)/<span class="keyword">sizeof</span>(argv[<span class="number">0</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argc&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the origin strings</span></span><br><span class="line">    <span class="comment">// &quot;C:\Users\25411\Desktop\test\test.exe&quot; &quot;1&quot; &quot;2.0&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;argc; ++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert strings to proper type atoi, ascii to int  </span></span><br><span class="line">    <span class="comment">// atof, ascii to float</span></span><br><span class="line">    <span class="comment">// atol, atoll</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;argv[<span class="number">0</span>]&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// &quot;C:\Users\25411\Desktop\test\test.exe&quot;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;atoi(argv[<span class="number">1</span>])&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;atof(argv[<span class="number">2</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ main函数带参数声明为&lt;code&gt;int main(int argc, char* argv[])&lt;/code&gt;。第一个参数代表参数个数，第二个参数代表参数字符串数组。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++访问权限控制关键字</title>
    <link href="http://xkwang.cn/post/b61a0d65.html"/>
    <id>http://xkwang.cn/post/b61a0d65.html</id>
    <published>2021-02-20T05:37:33.000Z</published>
    <updated>2021-02-23T05:11:38.159Z</updated>
    
    <content type="html"><![CDATA[<p>C++权限控制关键字包含public, private,  protected。</p><a id="more"></a><h3 id="从类自身去看"><a href="#从类自身去看" class="headerlink" title="从类自身去看"></a>从类自身去看</h3><ul><li>public类内和类外均可访问</li><li>private只能类内访问（特殊情况要访问使用友元类或者友元函数）</li><li>protected只能类内访问</li></ul><h3 id="从继承关系去看"><a href="#从继承关系去看" class="headerlink" title="从继承关系去看"></a>从继承关系去看</h3><h4 id="简单情况下"><a href="#简单情况下" class="headerlink" title="简单情况下"></a>简单情况下</h4><ul><li>public属性的成员和函数都可被子类访问</li><li>private属性的成员和函数不可被子类访问</li><li>protected属性的成员和函数可以被子类访问</li></ul><p><a href="#%E4%BB%A3%E7%A0%811">实验代码</a></p><p>虽然private属性成员不能被子类访问，但是子类中存在这些成员，只是被隐藏了。<a href="#%E4%BB%A3%E7%A0%812">实验代码</a></p><h4 id="公有继承、私有继承、保护继承"><a href="#公有继承、私有继承、保护继承" class="headerlink" title="公有继承、私有继承、保护继承"></a>公有继承、私有继承、保护继承</h4><blockquote><p>子类继承父类格式 class Child: [继承权限] Base1, [继承权限]Base2, … 其中继承权限分为3种。</p></blockquote><p>三种继承方式，在子类内部，父类成员的访问级别与父类相同，改变的只是用户代码（类外）的访问级别。</p><ul><li>public继承，继承之后子类外部访问父类成员权限不变；</li><li>private继承，继承之后子类外部访问父类成员权限全部变为private;</li><li>protected继承，继承之后子类外部访问父类成员public变成protected（可以进一步被继承使用），private还是private，protected还是protected。</li></ul><p>C++的权限控制保证了一般情况下用户代码（类外）不能访问private和protected的成员，子类不能访问父类private成员，子类能够访问父类protected成员。</p><h3 id="默认权限级别"><a href="#默认权限级别" class="headerlink" title="默认权限级别"></a>默认权限级别</h3><ul><li>class默认的权限级别是private，struct默认的权限级别是public。</li><li>继承的权限级别默认是private。</li></ul><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print1 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print2 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print3 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span>:</span> <span class="keyword">public</span> Child1&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// constructor must be public</span></span><br><span class="line">    Child2(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        x2=x3=x;</span><br><span class="line">        x1=x; <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Child1 d1;</span><br><span class="line">    d1.print3();</span><br><span class="line">    d1.x3=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    d1.print1(); <span class="comment">// error, declared private here</span></span><br><span class="line">    d1.x1=<span class="number">0</span>; <span class="comment">// error, declared private here</span></span><br><span class="line"></span><br><span class="line">    d1.print2(); <span class="comment">// error, declared protected here</span></span><br><span class="line">    d1.x2=<span class="number">0</span>; <span class="comment">// error, declared protected here</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Child2 <span class="title">d2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    d2.print2(); <span class="comment">// error</span></span><br><span class="line">    d2.x2=<span class="number">0</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;print1 is serving!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x1; <span class="comment">// 4 </span></span><br><span class="line">    <span class="keyword">float</span> x2; <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span>:</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Child1 d1;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d1)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是8的原因可以参考<a href="8f50d358.html">C++类和对象的存储结构</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++权限控制关键字包含public, private,  protected。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>OOP的三大特性</title>
    <link href="http://xkwang.cn/post/d91bc6a5.html"/>
    <id>http://xkwang.cn/post/d91bc6a5.html</id>
    <published>2021-02-20T04:03:03.000Z</published>
    <updated>2021-03-04T11:57:08.245Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程（OOP）的三大特性：封装、继承、多态。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>封装</strong>是指对象把自己的数据成员和对数据的操作封装在一起；<br><strong>继承</strong>是指子类（派生类）对父类（基类）的继承，子类把父类的数据和对数据的操作继承过来，同时又增添了自己的数据和对数据的操作；<br><strong>多态</strong>同一操作作用于不同对象，产生不同结果。主要体现为函数重载（静态多态，编译时确定）和虚函数（动态多态，运行时确定）。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承权限问题 参看<a href="b61a0d65.html">C++权限控制</a>；</li><li>继承带来的重写、重载、虚函数，后续介绍；</li><li>C++的多继承、菱形继承，后续补充。</li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>函数重载<br>相同函数名字，不同参数列表（含不同数量参数、不同种类参数）或const函数</li><li>运算符重载<br>相同的运算符作用于不同对象，产生不同结果。通过operator函数实现。</li></ul><p><strong>重写是指子类继承父类成员函数，但是对父类函数进行了重新实现，子类重写父类函数之后没办法直接访问到父类同名函数</strong></p><blockquote><p>与Java中可以通过super访问到父类不同，Java只允许单继承，因此super可以很唯一的指向父类，C++支持多继承，父类可能不止一个。因此，在C++中如果要在子类中访问父类的方法，只能用class::function()的方式进行。</p></blockquote><p>重写、重载、虚函数是设计继承需要考虑的问题。重写之后原来父类的方法子类不能访问；重载则子类可以访问父类的同名成员函数；重写会覆盖父类函数，重载则每个子类必须由自身对象进行调用，无法根据运行时进行灵活选择，因此有了虚函数的概念。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>子类中出现了和父类相同名字的虚函数也是一种重写，子类重写了父类的虚函数，有关虚函数的细节参考<a href="fa71210a.html">C++中的虚函数</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象编程（OOP）的三大特性：封装、继承、多态。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://xkwang.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客使用方法</title>
    <link href="http://xkwang.cn/post/782b19c0.html"/>
    <id>http://xkwang.cn/post/782b19c0.html</id>
    <published>2021-02-20T03:57:23.000Z</published>
    <updated>2021-02-20T03:59:15.518Z</updated>
    
    <content type="html"><![CDATA[<p>常用命令<code>hexo clean, hexo g, hexo g</code>。上传相册需要把相册保存到source/photos/ins目录下，然后在hexo根目录下运行python encode_jpg.py，实现图片压缩、缩略图生成。每次生成新的博客，在部署到github后需要运行<code>node comment.js</code>来批量化开启gitalk评论区。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;常用命令&lt;code&gt;hexo clean, hexo g, hexo g&lt;/code&gt;。上传相册需要把相册保存到source/photos/ins目录下，然后在hexo根目录下运行python encode_jpg.py，实现图片压缩、缩略图生成。每次生成新的博客，在部署到github后需要运行&lt;code&gt;node comment.js&lt;/code&gt;来批量化开启gitalk评论区。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://xkwang.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
